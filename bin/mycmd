#!/usr/bin/env bash
# -*- mode: shell-script; sh-shell: bash; sh-basic-offset: 4; sh-indentation: 4; coding: utf-8 -*-
# shellcheck shell=bash

set -o nounset -o errexit -o errtrace -o pipefail
shopt -s inherit_errexit

# ------------------------------------------------------------------------------
# Early Tracing and Debugging

# _MYCMD_EARLY_SHELL_TRACE and _MYCMD_EARLY_SHELL_VERBOSE are mainly for the ease of debugging
# MyCmd itself; since the MyCmd launcher is also in shell and sources mycmd-lib, if we check
# the user facing variables MYCMD_SHELL_TRACE and MYCMD_SHELL_VERBOSE and set the options here
# the output will have too much of the mechanics of MyCmd itself and not the user's command.

if [[ -n "${_MYCMD_EARLY_SHELL_TRACE-}" ]]; then
    if [[ -n "${_MYCMD_EARLY_TRACE_LOG_FILE-}" ]]; then
        PS4='+[${EPOCHREALTIME}][${BASH_SOURCE}:${LINENO}]:[${FUNCNAME[*]}]:'
        export PS4

        exec {_MYCMD_EARLY_TRACE_LOG_FD}>>"${_MYCMD_EARLY_TRACE_LOG_FILE}"
        readonly _MYCMD_EARLY_TRACE_LOG_FD
        export _MYCMD_EARLY_TRACE_LOG_FD
        BASH_XTRACEFD="${_MYCMD_EARLY_TRACE_LOG_FD}"
    fi

    set -o xtrace
fi

if [[ -n "${_MYCMD_EARLY_SHELL_VERBOSE-}" ]]; then
    set -o verbose
fi

# ------------------------------------------------------------------------------
# Setting up environment

function mycmd_launcher.set_mycmd_system_environment() {
    _MYCMD_LAUNCHER_SELF_FILE="${BASH_SOURCE[0]}"
    MYCMD_BIN_DIR=$(cd "$(dirname "${_MYCMD_LAUNCHER_SELF_FILE}")" &>/dev/null && pwd -P)
    readonly MYCMD_BIN_DIR
    export MYCMD_BIN_DIR

    if [[ -z "${MYCMD_SYSTEM_BASE_DIR-}" || ! -d "${MYCMD_SYSTEM_BASE_DIR}" ]]; then
        local -r system_base_dir_relative="${MYCMD_BIN_DIR}/../mycmd"

        if [[ ! -d "${system_base_dir_relative}" ]]; then
            echo >&2 "Cannot find MyCmd system library base directory in the standard location."
            exit 1
        fi

        if ! MYCMD_SYSTEM_BASE_DIR=$(cd "${system_base_dir_relative}" &>/dev/null && pwd -P); then
            echo >&2 "MYCMD_SYSTEM_BASE_DIR cannot be set."
            exit 1
        fi

        readonly MYCMD_SYSTEM_BASE_DIR
        export MYCMD_SYSTEM_BASE_DIR
    fi

    if [[ ! -e "${MYCMD_SYSTEM_BASE_DIR}/mycmd-lib" ]]; then
        echo >&2 "MYCMD_SYSTEM_BASE_DIR setting of ${MYCMD_SYSTEM_BASE_DIR} invalid, as required file mycmd-lib is missing."
        exit 1
    fi

    if [[ -z "${MYCMD_VENDOR_DIR-}" || ! -d "${MYCMD_VENDOR_DIR}" ]]; then
        local -r vendor_dir_relative="${MYCMD_BIN_DIR}/../vendor"

        if [[ ! -d "${vendor_dir_relative}" ]]; then
            echo >&2 "Cannot find MyCmd vendor library directory in the standard location."
            exit 1
        fi

        if ! MYCMD_VENDOR_DIR=$(cd "${vendor_dir_relative}" &>/dev/null && pwd -P); then
            echo >&2 "MYCMD_VENDOR_DIR cannot be set."
            exit 1
        fi

        readonly MYCMD_VENDOR_DIR
        export MYCMD_VENDOR_DIR
    fi
}

function mycmd_launcher.set_mycmd_user_environment() {
    if [[ -z "${MYCMD_USER_BASE_DIR-}" ]]; then
        MYCMD_USER_BASE_DIR="${HOME}/mycmd"
    fi

    if [[ ! -d "${MYCMD_USER_BASE_DIR}" ]]; then
        echo >&2 "Required MyCmd user library directory, '${MYCMD_USER_BASE_DIR}' not found."
        exit 1
    fi

    readonly MYCMD_USER_BASE_DIR
    export MYCMD_USER_BASE_DIR
}

# ------------------------------------------------------------------------------
# Set MYCMD_SYSTEM_BASE_DIR and MYCMD_USER_BASE_DIR
#
#   MYCMD_SYSTEM_BASE_DIR defaults to the mycmd directory that is parallel to
#   the bin directory that this mycmd script is in; have MYCMD_SYSTEM_BASE_DIR
#   set before launching to override this, however this directory must include
#   the mycmd-lib file that is included in the MyCmd distribution.
#
#   MYCMD_USER_BASE_DIR defaults to ~/mycmd; have MYCMD_USER_BASE_DIR set before
#   launching to override this.
#
# ------------------------------------------------------------------------------
# Validate MYCMD_SYSTEM_BASE_DIR setting and source MyCmd Base Library
mycmd_launcher.set_mycmd_system_environment
mycmd_launcher.set_mycmd_user_environment

# shellcheck source=./mycmd/mycmd-lib
source "${MYCMD_SYSTEM_BASE_DIR}/mycmd-lib" "${@}"

_MYCMD_LAUNCHER_SHIFT_AMOUNT="shift-amount"
_MYCMD_LAUNCHER_COMMAND_FULLY_QUALIFIED_NAME="command-fully-qualified-name"
_MYCMD_LAUNCHER_COMMAND_GROUP_FULLY_QUALIFIED_NAME="command-group-fully-qualified-name"

function mycmd_launcher.parse_command_line() {
    local -n arguments_ref="${1}"
    shift

    local -i shift_amount=0

    if [[ "${1}" = /* || "${1}" = ./* || "${1}" = ../* ]] && [[ -e "${1}" ]]; then
        local full_path="${1}"

        local fully_qualified_name
        if ! fully_qualified_name=$(mycmd:registry.find_matching_command_for_path "${full_path}"); then
            mycmd.debug "No match for '${fully_qualified_name}'."
            return 1
        fi
        readonly fully_qualified_name

        arguments_ref["${_MYCMD_LAUNCHER_COMMAND_FULLY_QUALIFIED_NAME}"]="${fully_qualified_name}"

        shift
        ((shift_amount += 1))
    else
        local fully_qualified_name="mycmd"
        local last_seen_command_group="mycmd"
        local command

        local element
        while (($# > 0)); do
            element="${1}"
            fully_qualified_name="${fully_qualified_name}/${element}"

            mycmd.trace "Examining path component '${element}'; with fully qualified name '${fully_qualified_name}'"

            if mycmd:registry.command_group_exists_for_fully_qualified_name "${fully_qualified_name}"; then
                mycmd.trace "Found command group with fully qualified name '${fully_qualified_name}'."
                last_seen_command_group="${fully_qualified_name}"

                shift
                ((shift_amount += 1))
            elif mycmd:registry.command_exists_for_fully_qualified_name "${fully_qualified_name}"; then
                mycmd.trace "Found command with fully qualified name '${fully_qualified_name}'."
                command="${fully_qualified_name}"

                shift
                ((shift_amount += 1))
                break
            else
                break
            fi
        done

        if [[ -n "${command:-}" ]]; then
            arguments_ref["${_MYCMD_LAUNCHER_COMMAND_FULLY_QUALIFIED_NAME}"]="${command}"
        else
            arguments_ref["${_MYCMD_LAUNCHER_COMMAND_GROUP_FULLY_QUALIFIED_NAME}"]="${last_seen_command_group}"
        fi
    fi

    arguments_ref["${_MYCMD_LAUNCHER_SHIFT_AMOUNT}"]="${shift_amount}"

    mycmd.debug "Parsed arguments:"

    if [[ -v arguments_ref["${_MYCMD_LAUNCHER_COMMAND_FULLY_QUALIFIED_NAME}"] ]]; then
        mycmd.debug "- Command Fully Qualified Name found:        ${arguments_ref["${_MYCMD_LAUNCHER_COMMAND_FULLY_QUALIFIED_NAME}"]}"
    else
        mycmd.debug "- No command found"
    fi

    if [[ -v arguments_ref["${_MYCMD_LAUNCHER_COMMAND_GROUP_FULLY_QUALIFIED_NAME}"] ]]; then
        mycmd.debug "- Command Group Fully Qualified Name found:  ${arguments_ref["${_MYCMD_LAUNCHER_COMMAND_GROUP_FULLY_QUALIFIED_NAME}"]}"
    else
        mycmd.debug "- No command group found"
    fi

    mycmd.debug "- Args shift count:                           ${arguments_ref["${_MYCMD_LAUNCHER_SHIFT_AMOUNT}"]}"

    if (($# > 0)); then
        mycmd.debug "- Remaining arguments:                       ${*}"
    else
        mycmd.debug "- No Remaining arguments on the command line."
    fi
}

function mycmd_launcher.main() {
    # Manually run the startup deferreds for the launcher
    mycmd.run_startup_deferreds

    declare -A launcher_dispatch=()
    mycmd_launcher.parse_command_line launcher_dispatch "${@}"

    local -r shift_amount="${launcher_dispatch["${_MYCMD_LAUNCHER_SHIFT_AMOUNT}"]}"
    shift "${shift_amount}"

    if [[ -v launcher_dispatch["${_MYCMD_LAUNCHER_COMMAND_FULLY_QUALIFIED_NAME}"] ]]; then
        local -r command_fully_qualified_name="${launcher_dispatch["${_MYCMD_LAUNCHER_COMMAND_FULLY_QUALIFIED_NAME}"]}"
        mycmd:command.execute_by_name "${command_fully_qualified_name}" "${@}"
    elif [[ -v launcher_dispatch["${_MYCMD_LAUNCHER_COMMAND_GROUP_FULLY_QUALIFIED_NAME}"] ]]; then
        local -r command_group_fully_qualified_name="${launcher_dispatch["${_MYCMD_LAUNCHER_COMMAND_GROUP_FULLY_QUALIFIED_NAME}"]}"
        mycmd.output "Only found reference to command group: '${command_group_fully_qualified_name}'."
    else
        mycmd.log "Unexpected state"
    fi
}

mycmd_launcher.main "${@}"

# -*- mode: shell-script; sh-shell: bash; sh-basic-offset: 4; sh-indentation: 4; coding: utf-8 -*-
# shellcheck shell=bash

# MyCmd Registry Support Library
#   Support for the MyCmd Registry of all discovered Command Groups and Commands

set -o nounset -o errexit -o errtrace -o pipefail

(return 0 >/dev/null 2>&1) || {
    echo >&2 "$0 is a library only meant to be sourced."
    exit 1
}

[[ -n "${_MYCMD_REGISTRY_LIB:-}" ]] && return
readonly _MYCMD_REGISTRY_LIB=1

if [[ ! -v _MYCMD_LIB_DIR ]]; then
    readonly _MYCMD_REGISTRY_LIB_SELF_FILE="${BASH_SOURCE[0]}"
    _MYCMD_LIB_DIR=$(cd "$(dirname "${_MYCMD_REGISTRY_LIB_SELF_FILE}")" &>/dev/null && pwd -P)
    readonly _MYCMD_LIB_DIR
fi

# ------------------------------------------------------------------------------
# Source Required Support Libraries
if [[ ! -v _MYCMD_LOADING_LIB ]]; then
    # shellcheck source=./mycmd-loading-lib
    source "${_MYCMD_LIB_DIR}/mycmd-loading-lib"
fi

mycmd.load_mycmd_lib_support_lib "function-calling"
mycmd.load_mycmd_lib_support_lib "output"
mycmd.load_mycmd_lib_support_lib "pathname"

# ------------------------------------------------------------------------------
## The MyCmd Registry
readonly _MYCMD_COMMAND_GROUP_TYPE='MyCmd Command Group'
readonly _MYCMD_COMMAND_TYPE='MyCmd Command'

# ------------------------------------------------------------------------------
# Global Registry Arrays
declare -agx _MYCMD_COMMAND_GROUPS=()
declare -agx _MYCMD_COMMANDS=()

declare -Agx _MYCMD_ITEM_TYPES=()
declare -Agx _MYCMD_ITEM_SOURCE_DIRECTORIES=()
declare -Agx _MYCMD_ITEM_SOURCE_FILE_PATHS=()

# ------------------------------------------------------------------------------
# MyCmd Registry Discovery Functions
function mycmd:registry.discover_command_groups_and_commands() {
    mycmd:pathname.walk_path "mycmd" mycmd:registry._discover_command_groups_and_commands_callback
}

function mycmd:registry._discover_command_groups_and_commands_callback() {
    local -r full_path="${1}"
    local -r fully_qualified_name="${2}"
    # The directories are not currently used
    local -n _dirs_ref="${3}"
    local -n files_ref="${4}"

    if ! mycmd:registry._register_command_group "${fully_qualified_name}" "${full_path}"; then
        mycmd.log "Error loading command group '${fully_qualified_name}' from '${full_path}'."
        return 1
    fi

    local f
    local file_fully_qualified_name
    local file_name
    for f in "${files_ref[@]}"; do
        if ! file_name="$(basename "${f}")"; then
            mycmd.log "Error getting basename of '${f}'."
            return 1
        fi

        file_fully_qualified_name="${fully_qualified_name}/${file_name}"

        if ! mycmd:registry._register_command "${file_fully_qualified_name}" "${f}"; then
            mycmd.log "Error loading command '${file_fully_qualified_name}' from '${f}'."
            return 1
        fi
    done
}

function mycmd:registry._register_command_group() {
    local -r fully_qualified_name="${1}"
    local -r source_directory="${2}"

    # If this is called by mycmd:pathname.walk_path, assuming directory paths are real and on the MyCmd Search Path
    if mycmd.is_called_by_function "mycmd:pathname.walk_path"; then
        mycmd.trace "Skipping validation of parameters, assuming they are valid, as called from 'mycmd:pathname.walk_path'."
    else
        if ! mycmd:registry._validate_directory_contains_command_group "${source_directory}"; then
            mycmd.debug "Directory ${source_directory} does not contain a command group."
            return 0
        fi
    fi

    local source_file_path
    if ! source_file_path="$(mycmd:registry._command_group_source_file_path_for_directory "${source_directory}")"; then
        mycmd.debug "Error getting source file name for command group library '${source_directory}'."
        return 1
    fi
    readonly source_file_path

    if [[ ! -e "${source_file_path}" ]]; then
        mycmd.debug "Expected command group library file '${source_file_path}' does not exist, '${fully_qualified_name}' is not a command group."
        return 0
    fi

    if ! mycmd:registry._register_item \
        _MYCMD_COMMAND_GROUPS \
        "${_MYCMD_COMMAND_GROUP_TYPE}" \
        "${fully_qualified_name}" \
        "${source_directory}" \
        "${source_file_path}"; then
        mycmd.debug "Error registering command group '${fully_qualified_name}'."
        return 1
    fi

    return 0
}

function mycmd:registry._register_command() {
    local -r fully_qualified_name="${1}"
    local -r source_file_path="${2}"

    if ! mycmd:registry._file_is_command "${source_file_path}"; then
        mycmd.debug "'${source_file_path}' is not a valid command."
        return 0
    fi

    local -r source_directory="$(dirname "${source_file_path}")"

    if ! mycmd:registry._register_item \
        _MYCMD_COMMANDS \
        "${_MYCMD_COMMAND_TYPE}" \
        "${fully_qualified_name}" \
        "${source_directory}" \
        "${source_file_path}"; then
        mycmd.debug "Error registering command '${fully_qualified_name}'."
        return 1
    fi

    return 0
}

function mycmd:registry._register_item() {
    local -n item_list_ref="${1}"
    local -r item_type="${2}"
    local -r fully_qualified_name="${3}"
    local -r source_directory="${4}"
    local -r source_file_path="${5}"

    if [[ -v _MYCMD_ITEM_TYPES[${fully_qualified_name}] ]]; then
        local -r existing_item_type="${_MYCMD_ITEM_TYPES[${fully_qualified_name}]}"

        if [[ "${existing_item_type}" != "${item_type}" ]]; then
            mycmd.debug "Item at '${fully_qualified_name}' already registered, but of type '${existing_item_type}', not '${item_type}'."
            return 1
        fi
    fi

    if [[ -v _MYCMD_ITEM_SOURCE_DIRECTORIES[${fully_qualified_name}] ]]; then
        local -r existing_source_directory="${_MYCMD_ITEM_SOURCE_DIRECTORIES[${fully_qualified_name}]}"

        if [[ "${existing_source_directory}" != "${source_directory}" ]]; then
            mycmd.debug "Item already registered at '${fully_qualified_name}' with source directory '${existing_source_directory}', not '${source_directory}'."
            return 1
        fi
    fi

    if [[ -v _MYCMD_ITEM_SOURCE_FILE_PATHS[${fully_qualified_name}] ]]; then
        local -r existing_source_file_path="${_MYCMD_ITEM_SOURCE_FILE_PATHS[${fully_qualified_name}]}"

        if [[ "${existing_source_file_path}" != "${source_file_path}" ]]; then
            mycmd.debug "Item already registered at '${fully_qualified_name}' with source file '${existing_source_file_path}', not '${source_file_path}'."
            return 1
        else
            mycmd.debug "Item '${fully_qualified_name}' has already been registered."
            return 0
        fi
    fi

    item_list_ref+=("${fully_qualified_name}")
    _MYCMD_ITEM_TYPES["${fully_qualified_name}"]="${item_type}"
    _MYCMD_ITEM_SOURCE_DIRECTORIES["${fully_qualified_name}"]="${source_directory}"
    _MYCMD_ITEM_SOURCE_FILE_PATHS["${fully_qualified_name}"]="${source_file_path}"

    return 0
}

function mycmd:registry._command_group_source_file_path_for_directory() {
    local -r source_directory="${1}"

    local name
    if ! name="$(basename "${source_directory}")"; then
        mycmd.debug "Error getting basename of '${source_directory}'."
        return 1
    fi
    readonly name

    local -r source_file_path="${source_directory}/${name}-lib"
    echo "${source_file_path}"
    return 0
}

function mycmd:registry._validate_directory_contains_command_group() {
    # A directory is a command group if:
    # - it is valid directory
    # - it is a child of one of the top-level MyCmd directories on the path
    # - it has a file named <command-group>/<command-group>-lib matching the directory
    local -r source_directory="${1}"

    if ! mycmd:pathname.is_valid_absolute_path_of_directory "${source_directory}"; then
        mycmd.debug "${source_directory} is not a valid absolute path of a directory."
        return 1
    fi

    if ! mycmd:pathname.is_child_of_mycmd_path_directory "${source_directory}"; then
        mycmd.debug "${source_directory} is not a descendant of any of the MyCmd base directories."
        return 1
    fi

    local source_file_path
    if ! source_file_path="$(mycmd:registry._command_group_source_file_path_for_directory "${source_directory}")"; then
        mycmd.debug "Error getting source file name for command group library '${source_directory}'."
        return 1
    fi
    readonly source_file_path

    if [[ ! -f "${source_file_path}" ]]; then
        mycmd.debug "Expected command group library file '${source_file_path}' does not exist."
        return 1
    fi

    return 0
}

function mycmd:registry._file_is_command() {
    local -r source_file_path="${1}"

    if ! mycmd:pathname.is_valid_absolute_path_of_executable_file "${source_file_path}"; then
        mycmd.debug "'${source_file_path}' is not a valid absolute path of an executable file."
        return 1
    fi

    if mycmd.is_called_by_function "mycmd:pathname.walk_path"; then
        mycmd.trace "Skipping validation of file is on MyCmd Search path, assuming it is, as called from 'mycmd:pathname.walk_path'."
    else
        if ! mycmd:pathname.is_child_of_mycmd_path_directory "${source_file_path}"; then
            mycmd.debug "'${source_file_path}' is not located on the MyCmd Search Path."
            return 1
        fi
    fi

    return 0
}

mycmd.trace "The MyCmd Registry support library has been sourced."

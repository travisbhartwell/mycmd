# -*- mode: shell-script; sh-shell: bash; sh-basic-offset: 4; sh-indentation: 4; coding: utf-8 -*-
# shellcheck shell=bash

# ------------------------------------------------------------------------------
# MyCmd Base Shell Library
#   Library to be sourced with common routines for MyCmd scripts and commands

# ------------------------------------------------------------------------------
# Basic Housekeeping
#
# Set options for safety
set -o nounset -o errexit -o errtrace -o pipefail

# This file should only be sourced and not executed directly, so exit with error
# with execution is attempted. Technique borrowed from
# https://stackoverflow.com/a/28776166
(return 0 >/dev/null 2>&1) || {
    echo >&2 "$0 is a library only meant to be sourced."
    exit 1
}

# This library should only be sourced once. Technique borrowed from
# https://stackoverflow.com/a/64534652
[[ -n "${_MYCMD_LIB-}" ]] && return
readonly _MYCMD_LIB=1

readonly _MYCMD_LIB_SELF_FILE="${BASH_SOURCE[0]}"

[[ -n "${_MYCMD_TRACE_LOG_FILE-}" ]] && {
    # PS4='+[${EPOCHREALTIME}][${BASH_SOURCE}:${LINENO}]:[${FUNCNAME[0]:+${FUNCNAME[0]}()}]:'
    PS4='+[${EPOCHREALTIME}][${BASH_SOURCE}:${LINENO}]:[${FUNCNAME[0]:+${FUNCNAME[0]}()}]:[${FUNCNAME[*]}]:'
    export PS4

    exec {_MYCMD_TRACE_LOG_FD}>>"${_MYCMD_TRACE_LOG_FILE}"
    BASH_XTRACEFD="${_MYCMD_TRACE_LOG_FD}"
    set -o xtrace
}

# _MYCMD_EARLY_SHELL_TRACE and _MYCMD_EARLY_SHELL_VERBOSE are mainly for the ease of debugging
# MyCmd itself; since the MyCmd launcher is also in shell and sources mycmd-lib, if we check
# the user facing variables MYCMD_SHELL_TRACE and MYCMD_SHELL_VERBOSE and set the options here
# the output will have too much of the mechanics of MyCmd itself and not the user's command.
[[ -n "${_MYCMD_EARLY_SHELL_TRACE-}" ]] && set -o xtrace

[[ -n "${_MYCMD_EARLY_SHELL_VERBOSE-}" ]] && set -o verbose

# ------------------------------------------------------------------------------
# Library Protection
function mycmd.capture_unprotected_functions() {
    local -n array_ref="${1}"
    # shellcheck disable=SC2034
    readarray -t array_ref < <(declare -F | grep -v "^declare \-fr" | cut -d' ' -f3 | sort || true)
}

declare -a _mycmd_lib_functions_before=()
mycmd.capture_unprotected_functions _mycmd_lib_functions_before

function mycmd.protect_library_functions() {
    local -n before_functions="${1}"
    local -n after_functions="${2}"
    local -A seen_functions=()

    # First add the existing functions to an associative array
    local f
    for f in "${before_functions[@]}"; do
        seen_functions["${f}"]=1
    done

    for f in "${after_functions[@]}"; do
        if [[ ! -v seen_functions["${f}"] ]]; then
            mycmd.trace "Marking function '${f}' read-only."
            readonly -f "${f}"
        else
            mycmd.trace "Skipping marking pre-existing function '${f}' read-only."
        fi
    done
}

function mycmd._protect_mycmd_lib() {
    # shellcheck disable=SC2034
    local -a mycmd_lib_functions_after
    mycmd.capture_unprotected_functions mycmd_lib_functions_after

    mycmd.trace "Manually marking 'mycmd.capture_unprotected_functions' as read-only."
    readonly -f mycmd.capture_unprotected_functions

    mycmd.protect_library_functions _mycmd_lib_functions_before mycmd_lib_functions_after

    unset -f _mycmd_lib_functions_before
}

# ------------------------------------------------------------------------------
# Basic Logging and Output Functions
#
#   These are defined as early as possible to enable to be used through-out this
#   file. See the Additional Logging Support section below for additional
#   functionality.
#
#   In general, use these functions for any output that the user may see, and use
#   echo for interal implementation use for functions that are meant to be called
#   in sub-shells to capture output.

# These file descriptors are set up to make output easier
exec {_MYCMD_OUTPUT_FD}>&1
readonly _MYCMD_OUTPUT_FD
export _MYCMD_OUTPUT_FD

if [[ -v _MYCMD_TESTING ]]; then
    declare -ax _MYCMD_OUTPUT_ARRAY=()

    function mycmd._reset_output() {
        _MYCMD_OUTPUT_ARRAY=()
    }

    # mycmd.output
    #   Convenience for runtime output to stdout. Provided for symmetry in output
    #   functions.
    function mycmd._output() {
        local -r output_fd="${1}"
        shift

        local output
        printf -v output '%b\n' "$*"
        _MYCMD_OUTPUT_ARRAY+=("${output}")

        echo -e "${output}" >&"${output_fd}"
    }
else
    # mycmd.output
    #   Convenience for runtime output to stdout. Provided for symmetry in output
    #   functions.
    function mycmd._output() {
        local -r output_fd="${1}"
        shift

        printf '%b\n' "$*" >&"${output_fd}"
    }
fi

# mycmd.output
#   Convenience for runtime output to stdout. Provided for symmetry in output
#   functions.
function mycmd.output() {
    mycmd._output "${_MYCMD_OUTPUT_FD}" "$*"
}

function mycmd._output_with_timestamp() {
    local -r output_fd="${1}"
    shift

    printf '[%(%F %T)T] %b\n' -1 "$*" 1>&"${output_fd}"
}

# mycmd.output_with_timestamp
#   Convenience for runtime output to stdout, with each line prefixed by the
#   current timestamp.
function mycmd.output_with_timestamp() {
    mycmd._output_with_timestamp "${_MYCMD_OUTPUT_FD}" "$*"
}

exec {_MYCMD_LOG_FD}>&2
readonly _MYCMD_LOG_FD
export _MYCMD_LOG_FD

# mycmd.log
#   Convenience for runtime logging to stderr.
function mycmd.log() {
    mycmd._output_with_timestamp "${_MYCMD_LOG_FD}" "$*"
}

# mycmd.debug
#   Optionally log when MYCMD_DEBUG is set. Useful for debugging output.
function mycmd.debug() {
    if [[ -n "${MYCMD_DEBUG-}" ]]; then
        mycmd.log "[DEBUG] $*"
    fi
}

# mycmd.trace
#   Optionally log when MYCMD_TRACE is set. Useful for tracing script execution.
function mycmd.trace() {
    if [[ -n "${MYCMD_TRACE-}" ]]; then
        mycmd.log "[TRACE] $*"
    fi
}

# mycmd.err_exit
#   Output an error message to stderr and exit with a non-zero exit code.
#
#   $1 - Exit code to use
#   Remainder - Error message
function mycmd.err_exit() {
    local -r exit_code=$1
    shift

    mycmd.log "${*}"
    exit "${exit_code}"
}

# ------------------------------------------------------------------------------
# Validate environment
if [[ -z "${MYCMD_SYSTEM_BASE_DIR-}" ]]; then
    mycmd.err_exit 1 "Required environment variable MYCMD_SYSTEM_BASE_DIR is not set."
fi

if [[ ! -d "${MYCMD_SYSTEM_BASE_DIR}" ]]; then
    mycmd.err_exit 1 "Required directory referenced in environment variable MYCMD_SYSTEM_BASE_DIR, '${MYCMD_SYSTEM_BASE_DIR}' does not exist."
fi
mycmd.trace "MYCMD_SYSTEM_BASE_DIR: ${MYCMD_SYSTEM_BASE_DIR}"

if [[ -z "${MYCMD_USER_BASE_DIR-}" ]]; then
    mycmd.err_exit 1 "Required environment variable MYCMD_USER_BASE_DIR is not set."
fi

if [[ ! -d "${MYCMD_USER_BASE_DIR}" ]]; then
    mycmd.err_exit 1 "Required directory referenced in environment variable MYCMD_USER_BASE_DIR, '${MYCMD_USER_BASE_DIR}' does not exist."
fi
mycmd.trace "MYCMD_USER_BASE_DIR:   ${MYCMD_USER_BASE_DIR}"

if [[ -z "${MYCMD_VENDOR_DIR-}" ]]; then
    mycmd.err_exit 1 "Required environment variable MYCMD_VENDOR_DIR is not set."
fi

if [[ ! -d "${MYCMD_VENDOR_DIR}" ]]; then
    mycmd.err_exit 1 "Required directory referenced in environment variable MYCMD_VENDOR_DIR, '${MYCMD_VENDOR_DIR}' does not exist."
fi
mycmd.trace "MYCMD_VENDOR_DIR:      ${MYCMD_VENDOR_DIR}"

# ------------------------------------------------------------------------------
# Vendor Library Support

# mycmd._source_lib_by_path_if_found
#  Loads the specified library by full path, if it exists. This is not the full version
#  to enable loading libraries that are required for the full version.
function mycmd._source_lib_by_path_if_found() {
    local -r library_full_path="${1}"
    shift

    if [[ -e "${library_full_path}" ]]; then
        # shellcheck disable=2034
        local -a existing_functions=()
        mycmd.capture_unprotected_functions existing_functions

        # shellcheck source=/dev/null
        if ! source "${library_full_path}" "${@}"; then
            mycmd.log "Error while sourcing '${library_full_path}'."
            return 1
        else
            mycmd.trace "Finished sourcing '${library_full_path}'."
        fi

        # shellcheck disable=2034
        local -a current_functions=()
        mycmd.capture_unprotected_functions current_functions
        mycmd.protect_library_functions existing_functions current_functions

        return 0
    else
        mycmd.trace "Library '${library_full_path}' not found."
        return 1
    fi
}

function mycmd.load_vendor_library() {
    local -r vendor_library="${1}"
    # shellcheck disable=SC2154
    local -r vendor_library_path="${MYCMD_VENDOR_DIR}/${vendor_library}"

    mycmd.trace "Attempting to load vendored library '${vendor_library}'."

    if ! mycmd._source_lib_by_path_if_found "${vendor_library_path}"; then
        mycmd.log "Vendored library '${vendor_library}' not found."
        return 1
    fi
}

# ------------------------------------------------------------------------------
# Event Handling Support
if ! mycmd.load_vendor_library "bashup.events"; then
    mycmd.err_exit 1 "Required vendor library 'bashup.events' missing."
fi

# mycmd.event
#   Simple wrapper around bashup.event to present a consistent
#   interface to MyCmd command implementors.
function mycmd.event() {
    event "${@}"
}

# -------------------------------------------------------------------------------
# Library Deferred Commands Support
#
#   Commands to run after all libraries are sourced

# mycmd._dispatch_with_calling_file
#   Higher order function that passes the full pathname of the shell file that called the
#   function that called mycmd._dispatch_with_calling_file as the first parameter of the
#   function.
function mycmd._dispatch_with_calling_file() {
    mycmd._dispatch_with_calling_file_up_frames 1 "${@}"
}

function mycmd._dispatch_with_calling_file_up_frames() {
    local -r frames="${1}"
    shift
    local -r fn="${1}"
    shift

    local calling_file
    # stack frame 0 - who called me
    # stack frame 1 - who called that
    # etc
    read -r _ _ calling_file <<<"$(caller "${frames}" || true)"
    # TODO: Do I need to get an abspath?
    readonly calling_file
    mycmd.trace "Dispatching with calling file '${calling_file}'"

    "${fn}" "${calling_file}" "${@}"
}

function mycmd._get_file_startup_event_name() {
    local -r calling_file=${1}
    local -r event_name="${1}:mycmd_startup"

    echo "${event_name}"
}

function mycmd._defer_at_startup() {
    local -r calling_file="${1}"
    shift

    local event_name
    if ! event_name="$(mycmd._get_file_startup_event_name "${calling_file}")"; then
        mycmd.log "Error getting file startup event name"
        return 1
    fi
    readonly event_name

    mycmd.event on "${event_name}" "${@}"
}

# mycmd.defer_at_startup
#  Called with a command to call at the end of evaluating the library.
#
#  These commands are explicitly called by the explicit call to
#  mycmd.run_startup_deferreds at the end of this file.
function mycmd.defer_at_startup() {
    mycmd._dispatch_with_calling_file mycmd._defer_at_startup "${@}"
}

# mycmd.run_startup_deferreds
#   Supports two calling mechanism: one by the library explicitly, like from
#   this file. Or another on behalf of another file.
#
#   A quirk of how mycmd._dispatch_with_calling_file works allows us to be
#   recursive here
# shellcheck disable=SC2120
function mycmd.run_startup_deferreds() {
    if (($# < 1)); then
        mycmd._dispatch_with_calling_file "${FUNCNAME[0]}"
        return $?
    fi

    local -r calling_file="${1}"

    local event_name
    if ! event_name="$(mycmd._get_file_startup_event_name "${calling_file}")"; then
        mycmd.log "Error getting file startup event name"
        return 1
    fi
    readonly event_name

    if mycmd.event has "${event_name}"; then
        mycmd.trace "Calling deferred startup events for ${calling_file}."
        mycmd.event fire "${event_name}"
    fi
}

# -------------------------------------------------------------------------------
# Library clean up commands support
#   Basic clean up and error handling commands
readonly _MYCMD_EXIT_EVENT="mycmd_exit"

function mycmd.defer_at_exit() {
    mycmd.event on "${_MYCMD_EXIT_EVENT}" "${@}"
}

function mycmd._print_stack_trace() {
    mycmd.trace "Running ${FUNCNAME[0]}, with args '$*'"

    # Disable the trap
    trap - ERR

    # Method borrowed from https://raimonster.com/scripting-field-guide/#org3417a0c
    local return_code=$1

    ((return_code == 0)) && return 0

    mycmd.log "\nThe command ${BASH_COMMAND} triggered a stack trace."

    local -i i
    local -i j

    for i in $(seq 1 $((${#FUNCNAME[@]} - 2))); do
        j=$((i + 1))
        mycmd.log "\t ${BASH_SOURCE[${i}]}: ${FUNCNAME[${i}]}() called in ${BASH_SOURCE[${j}]}:${BASH_LINENO[${i}]}"
    done
}

function mycmd._run_at_exit_deferreds() {
    # Disable the trap handler, including ERR here just in case, as this should be run last
    trap - SIGINT SIGTERM ERR EXIT

    if mycmd.event has "${_MYCMD_EXIT_EVENT}"; then
        mycmd.trace "Calling deferred at exit events."
        mycmd.event fire "${_MYCMD_EXIT_EVENT}"
    fi

    mycmd.trace "All at exit deferreds execution completed."
}

trap 'mycmd._print_stack_trace $?' ERR
trap mycmd._run_at_exit_deferreds SIGINT SIGTERM EXIT

# ------------------------------------------------------------------------------
# Convenience methods for calling functions

# mycmd.function_exists
#   Test whether the specified shell function has been defined
function mycmd.function_exists() {
    declare -F "$1" >/dev/null
}

# mycmd.call_if_function_exists
#  	If the named function exists, call with the subsequent arguments. Otherwise,
#  	do nothing.
function mycmd.call_if_function_exists() {
    local -r fn=$1
    shift

    if mycmd.function_exists "${fn}"; then
        "${fn}" "$@"
    fi
}

# -------------------------------------------------------------------------------
# MyCmd Operating System Support
#   Common variables set according to OS being run on.
_MYCMD_OS="$(uname -s)"
readonly _MYCMD_OS

function mycmd.is_mac_os() {
    [[ "${_MYCMD_OS}" == "Darwin" ]]
}

function mycmd.is_linux() {
    [[ "${_MYCMD_OS}" == "Linux" ]]
}

# ------------------------------------------------------------------------------
# Convenience methods for locating common utilities cross platform

# MYCMD_BIN
#   An associative array used for dependencies that are in different
#   locations and/or names depending on the platform or host a script is
#   being run on.
#
#     Keys:  command names
#     Value: the path of the given command
declare -gAx MYCMD_BIN

# mycmd._locate_bin
#   If already defined in MYCMD_BIN, return that. Otherwise, attempt to find the given command on the PATH.
#   If found, return the full path.
function mycmd._locate_bin() {
    local -r command=$1
    local command_path

    if [[ -v MYCMD_BIN["${command}"] ]]; then
        command_path="${MYCMD_BIN[${command}]}"
    elif ! command_path=$(command -v "${command}" 2>/dev/null); then
        return 1
    fi

    echo "${command_path}"
}

function mycmd.init_bin_homebrew() {
    local -r exit_on_failure=$1
    local -r command=$2
    local -r exe_name=$3
    local -r long_name=$4
    local -r homebrew_package=$5

    local exe_path
    if exe_path=$(mycmd._locate_bin "${exe_name}"); then
        MYCMD_BIN[${command}]="${exe_path}"
        return 0
    elif [[ "${exit_on_failure}" = "true" ]]; then
        mycmd.err_exit 1 "Unable to locate ${long_name}, please install from Homebrew with 'brew install ${homebrew_package}'"
    else
        return 1
    fi
}

# mycmd.init_bin_no_exit
#  If not already set, attempt to set MYCMD_BIN for the given command name.
#
#  This version just returns 1 if the command isn't found, intending for the use case
#  of graceful fallbacks to Bash builtins or other implementations where optional dependencies
#  are missing.
function mycmd.init_bin_no_exit() {
    mycmd._init_bin false "${@}"
}

# mycmd.init_bin
#  If not already set, attempt to set MYCMD_BIN for the given command name.
#
#  It is intended that when this function is callled, the command is a required
#  dependency and thus this will exit with an error if the command cannot be found.
function mycmd.init_bin() {
    mycmd._init_bin true "${@}"
}

# mycmd._init_bin
#  Common functionality for mycmd.init_bin and mycmd.init_bin_no_exit. Will
#  first call mycmd_local.init_bin, if the user has defined mycmd-local-lib,
#  and use the value from there as an override.
#
#  Common commands like sed, which require a different name if using GNU set installed
#  from HomeBrew on Mac OS, are included here.
function mycmd._init_bin() {
    local -r exit_on_failure=$1
    local -r command=$2

    mycmd.call_if_function_exists mycmd_local.init_bin "$@"

    [[ -v MYCMD_BIN["${command}"] ]] && {
        mycmd.debug "'${command}' already defined at '${MYCMD_BIN[${command}]}'"
        return 0
    }

    local found_command=0

    local command_path

    case "${command}+${_MYCMD_OS}" in
        "awk+Darwin")
            mycmd.init_bin_homebrew "${exit_on_failure}" awk gawk "GNU awk" gawk || found_command=$?
            ;;
        "find+Darwin")
            mycmd.init_bin_homebrew "${exit_on_failure}" find gfind "GNU find" findutils || found_command=$?
            ;;
        "realpath+Darwin")
            mycmd.init_bin_homebrew "${exit_on_failure}" realpath grealpath "GNU realpath" coreutils || found_command=$?
            ;;
        "sed+Darwin")
            mycmd.init_bin_homebrew "${exit_on_failure}" sed gsed "GNU Sed" "gnu-sed" || found_command=$?
            ;;
        "stat+Darwin")
            mycmd.init_bin_homebrew "${exit_on_failure}" sed gstat "GNU Stat" coreutils || found_command=$?
            ;;
        "wc+Darwin")
            mycmd.init_bin_homebrew "${exit_on_failure}" wc gwc "GNU wc" coreutils || found_command=$?
            ;;
        "sha1sum+Darwin")
            local shasum_path
            # shasum is the implementation that ships with mac OS. SHA1 is the default algorithm so it is
            # a drop in for most cases
            if shasum_path=$(mycmd._locate_bin shasum); then
                MYCMD_BIN[${command}]="${shasum_path}"
            else
                found_command=1
            fi
            ;;
        *)
            if command_path=$(mycmd._locate_bin "${command}"); then
                MYCMD_BIN[${command}]="${command_path}"
            else
                found_command=1
            fi
            ;;
    esac

    if ((found_command == 0)); then
        return 0
    fi

    if [[ "${exit_on_failure}" = "true" ]]; then
        mycmd.err_exit 1 "Unable to locate ${command}."
    else
        return 1
    fi
}

function mycmd.bin_execute() {
    local -r command="${1}"
    shift

    local command_path
    if ! command_path=$(mycmd._locate_bin "${command}"); then
        mycmd.log "Could not find command '${command}'."
        return 1
    fi
    readonly command_path

    "${command_path}" "${@}"
}

# -------------------------------------------------------------------------------k
# MyCmd Command and Command Group Execution and Loading Support

# First, helpful constants used in output
readonly _MYCMD_DESC="MyCmd"
readonly _MYCMD_COMMAND_GROUP_DESC="${_MYCMD_DESC} Command Group"
readonly _MYCMD_COMMAND_DESC="${_MYCMD_DESC} Command"

function mycmd.source_command_for_help() {
    declare -gx MYCMD_COMMAND_ABSPATH="${1}"
    shift

    declare -gx _MYCMD_SOURCING_COMMAND_FOR_HELP=1
    if ! mycmd.source_lib_by_path_if_found "${MYCMD_COMMAND_ABSPATH}" "${@}"; then
        mycmd.err_exit 1 "MyCmd command '${MYCMD_COMMAND_ABSPATH}' not found."
    fi
    unset _MYCMD_SOURCING_COMMAND_FOR_HELP
}

# mycmd.source_command_group_for_help
function mycmd.source_command_group_for_help() {
    local -r command_group_path="${1}"
    shift

    declare -gx _MYCMD_SOURCING_COMMAND_GROUP_FOR_HELP=1
    if ! mycmd.source_mycmd_lib "${command_group_path}"; then
        mycmd.err_exit 1 "MyCmd Command Group '${command_group_path}' not found."
    fi
    unset _MYCMD_SOURCING_COMMAND_GROUP_FOR_HELP
}

# mycmd.execute_command
#  Execute a MyCmd command, given the full path to the command.
function mycmd.execute_command() {
    declare -rx MYCMD_COMMAND_ABSPATH="${1}"
    shift

    if ! mycmd.source_lib_by_path_if_found "${MYCMD_COMMAND_ABSPATH}" "${@}"; then
        mycmd.err_exit 1 "MyCmd command '${MYCMD_COMMAND_ABSPATH}' not found."
    fi

    if ! mycmd.load_command_group_for_command "${@}"; then
        mycmd.err_exit 1 "Error loading command group libraries for command '${MYCMD_COMMAND_ABSPATH}'."
    fi

    if ! mycmd.function_exists mycmd.main; then
        mycmd.err_exit 1 "'mycmd.main' not defined in MyCmd command '${MYCMD_COMMAND_ABSPATH}'."
    fi

    # Turn on tracing and verbose mode before executing script, if set
    [[ -n "${MYCMD_SHELL_TRACE-}" ]] && set -o xtrace

    [[ -n "${MYCMD_SHELL_VERBOSE-}" ]] && set -o verbose

    mycmd.main "${@}"

    exit $?
}

function mycmd.running_command_abspath() {
    if [[ ! -v MYCMD_COMMAND_ABSPATH ]]; then
        mycmd.log "MYCMD_COMMAND_ABSPATH not yet set; perhaps not yet executing a MyCmd Command"
        return 1
    fi

    echo "${MYCMD_COMMAND_ABSPATH}"
    return 0
}

function mycmd.running_command_name() {
    if [[ ! -v MYCMD_COMMAND_ABSPATH ]]; then
        mycmd.log "MYCMD_COMMAND_ABSPATH not yet set; perhaps not yet executing a MyCmd Command"
        return 1
    fi

    basename "${MYCMD_COMMAND_ABSPATH}"
    return 0
}

# mycmd.command_or_group_parts_from_path
#   Returns the command group name -- basically the space separated hierarchy -- given a command or command group relative path.
function mycmd.command_or_group_parts_from_path() {
    local -r command_or_group_path="${1}"
    local -r output_prefix="${2}"

    if [[ "${command_or_group_path}" = "${MYCMD_SYSTEM_BASE_DIR}" ]]; then
        echo "${_MYCMD_DESC}"
    fi

    mycmd.trace "Calling with '${command_or_group_path}'."
    local relative_path
    if ! relative_path="$(mycmd.path_relative_to_mycmd_base "${command_or_group_path}")"; then
        mycmd.log "Error fetching relative_path for ${command_or_group_path}."
        return 1
    fi
    readonly relative_path

    local parts
    # shellcheck disable=SC2162
    IFS="/" read -a parts <<<"${relative_path}"
    readonly parts

    echo "${output_prefix} ${parts[*]}"
}

function mycmd.running_command_parts_from_path() {
    if [[ ! -v MYCMD_COMMAND_ABSPATH ]]; then
        mycmd.log "MYCMD_COMMAND_ABSPATH not yet set; perhaps not yet executing a MyCmd Command"
        return 1
    fi

    if output="$(mycmd.command_or_group_parts_from_path "${MYCMD_COMMAND_ABSPATH}" "mycmd")"; then
        echo "${output}"
        return 0
    else
        return 1
    fi
}

# mycmd.source_lib_by_path_if_found
#   Source the library if it exists.
function mycmd.source_lib_by_path_if_found() {
    local -r library_full_path="${1}"
    shift

    if mycmd._source_lib_by_path_if_found "${library_full_path}" "${@}"; then
        mycmd.trace "Library '${library_full_path}' successfully loaded, running startup deferreds."
        # Run any remaining deferreds for the startup for the library
        mycmd.run_startup_deferreds "${library_full_path}"

        return 0
    else
        mycmd.trace "Library '${library_full_path}' not found."
        return 1
    fi
}

mycmd.defer_at_startup mycmd.init_bin realpath
function mycmd.canonicalize_path() {
    local -r path_to_resolve="${1}"

    if [[ -v missing_ok ]]; then
        mycmd.bin_execute realpath --canonicalize-missing --quiet --logical "${path_to_resolve}"
    else
        mycmd.bin_execute realpath --canonicalize-existing --quiet --logical "${path_to_resolve}"
    fi
}

# mycmd._path_relative_to_directory
#   Given an absolute path to a command or command group, output the relative path to
#   the base directory specified.
#
#   Returns 1 if the specified path is not a descendant of the base directory.
mycmd.defer_at_startup mycmd.init_bin realpath
function mycmd._path_relative_to_directory() {
    local -r full_path="${1}"
    local -r base_path="${2}"

    local relative_path
    if ! relative_path="$(mycmd.bin_execute realpath --relative-to="${base_path}" "${full_path}")"; then
        mycmd.log "Error getting relative path for '${full_path}' relative to '${base_path}'."
        return 1
    fi
    readonly relative_path

    # If the relative path starts with .., it is not a descendant
    if [[ "${relative_path}" = ..* ]]; then
        return 1
    else
        echo "${relative_path}"
        return 0
    fi
}

# mycmd.path_relative_to_mycmd_base_with_command_group
#   Given an absolute path to a command or command group, return the relative path
#   in comparison to either MYCMD_SYSTEM_BASE_DIR or MYCMD_USER_BASE_DIR.
function mycmd.path_relative_to_mycmd_base_with_command_group() {
    # Assume that full_path is going to be a canonicalized absolute path
    local -r full_path="${1}"
    local -r command_group="${2-}"

    local base
    # shellcheck disable=SC2154
    for base in "${MYCMD_SYSTEM_BASE_DIR}" "${MYCMD_USER_BASE_DIR}"; do
        local relative_path
        if relative_path=$(mycmd._path_relative_to_directory "${full_path}" "${base}${command_group:+/}${command_group-}"); then
            echo "${relative_path}"
            return 0
        fi
    done

    return 1
}

# mycmd.path_relative_to_mycmd_base
#   Given an absolute path to a command or command group, return the relative path
#   in comparison to either MYCMD_SYSTEM_BASE_DIR or MYCMD_USER_BASE_DIR.
function mycmd.path_relative_to_mycmd_base() {
    # We assume that full_path is going to be a canonicalized absolute path
    local -r full_path="${1}"

    mycmd.path_relative_to_mycmd_base_with_command_group "${full_path}"
}

# mycmd.running_command_relative_path
function mycmd.running_command_relative_path() {
    if [[ ! -v MYCMD_COMMAND_ABSPATH ]]; then
        mycmd.err_exit 1 "MYCMD_COMMAND_ABSPATH must be set before calling mycmd.running_command_relative_path."
    fi

    local -r running_command_directory="$(dirname "${MYCMD_COMMAND_ABSPATH}")"
    local relative_path

    if relative_path="$(mycmd.path_relative_to_mycmd_base "${running_command_directory}")"; then
        echo "${relative_path}"
        return 0
    else
        mycmd.debug "Error getting running command relative path for ${MYCMD_COMMAND_ABSPATH}."
        return 1
    fi
}

# mycmd.source_mycmd_lib
#   Explicitly source a MyCmd library and its dependencies by providing the
#   directory name of the MyCmd library relative to either first
#   MYCMD_SYSTEM_BASE_DIR or, secondly, MYCMD_USER_BASE_DIR.
#
#   For example, to source the library in ~/mycmd/requests/service1, call this
#   like this:
#
#   mycmd.source_mycmd_lib "requests/service1"
function mycmd.source_mycmd_lib() {
    local -r library_path="$1"
    shift

    local dir_parts
    # shellcheck disable=SC2162
    IFS="/" read -a dir_parts <<<"${library_path}"
    readonly dir_parts

    # Start at the system base directory
    local lib_dir="${MYCMD_SYSTEM_BASE_DIR}"
    local local_lib_dir="${MYCMD_USER_BASE_DIR}"

    local dir
    for dir in "${dir_parts[@]}"; do
        lib_dir="${lib_dir}/${dir}"
        local_lib_dir="${local_lib_dir}/${dir}"

        # Look for a command group library named <dirname>-lib in <dirname>
        local lib_script="${lib_dir}/${dir}-lib"

        # First check in MYCMD_SYSTEM_BASE_DIR
        if mycmd.source_lib_by_path_if_found "${lib_script}" "${@}"; then
            # If found, source the local overrides file from MYCMD_USER_BASE_DIR, if it exists
            local local_lib_override="${local_lib_dir}/${dir}-local-lib"
            mycmd.source_lib_by_path_if_found "${local_lib_override}" "${@}"
        else
            # Otherwise, check in MYCMD_USER_BASE_DIR
            local local_lib_script="${local_lib_dir}/${dir}-lib"
            if ! mycmd.source_lib_by_path_if_found "${local_lib_script}" "${@}"; then
                mycmd.log "Cannot find library '${dir}' in system or user directory."
                return 1
            fi
        fi
    done

    return 0
}

# mycmd.source_mycmd_local_lib
function mycmd.source_mycmd_local_lib() {
    local -r local_lib="${MYCMD_USER_BASE_DIR}/mycmd-local-lib"

    mycmd.source_lib_by_path_if_found "${local_lib}" || true
}

# mycmd.load_command_group_for_command
#  Source the libraries for the command group that the to be executed MyCmd command
#  belongs to.
function mycmd.load_command_group_for_command() {
    local relative_path
    if ! relative_path=$(mycmd.running_command_relative_path); then
        mycmd.debug "${MYCMD_COMMAND_ABSPATH-} is not in any command group."
        return
    fi

    if [[ "${relative_path}" == "." ]]; then
        mycmd.trace "No additional libraries to automatically source, command is in system or user base directory."
        return
    fi

    mycmd.source_mycmd_lib "${relative_path}" "${@}"
}

# ------------------------------------------------------------------------------
# Convenience methods and variables for terminal output
if ! mycmd.load_vendor_library ansi; then
    mycmd.log "Cannot load vendored library, ansi, providing no op pass through."

    function mycmd.ansi() {
        return 0
    }
else
    function mycmd.ansi() {
        local -r fn="ansi::${1}"
        shift

        mycmd.call_if_function_exists "${fn}" "${@}"
    }
fi

# ------------------------------------------------------------------------------
# Additional Logging Support Functions
mycmd.defer_at_startup mycmd.init_bin sed
function mycmd._log_input() {
    local fn=$1

    # shellcheck disable=SC2312
    mycmd.log "$(mycmd.ansi bold)Start of input to '${fn}' on STDIN:$(mycmd.ansi normal)"

    # shellcheck disable=SC2312
    cat - | mycmd.bin_execute sed -e "s/\(.*\)/$$(mycmd.ansi bold)INPUT:$(mycmd.ansi normal)\t \1/" >&"${_MYCMD_LOG_FD}"

    # shellcheck disable=SC2312
    mycmd.log "\n$(mycmd.ansi bold)End of input to '${fn}' on STDIN.$(mycmd.ansi normal)"
}

mycmd.defer_at_startup mycmd.init_bin sed
function mycmd._log_output() {
    local fn=$1

    # shellcheck disable=SC2312
    mycmd.log "$(mycmd.ansi bold)Start of output from '${fn}' on STDOUT:$(mycmd.ansi normal)"

    # shellcheck disable=SC2312
    cat - | mycmd.bin_execute sed -e "s/\(.*\)/$(mycmd.ansi bold)OUTPUT:$(mycmd.ansi normal)\t \1/" >&"${_MYCMD_LOG_FD}"

    # shellcheck disable=SC2312
    mycmd.log "\n$(mycmd.ansi bold)End of output from '${fn}' on STDOUT.$(mycmd.ansi normal)"
}

# mycmd.log_function
#   Used to easily trace execution of a shell script.
#   Logs - by default to stderr - the following:
#   - any arguments used to call the function
#   - any input on stdin to the function
#   - any output on stderr from the function
function mycmd.log_function() {
    local -r fn=$1
    shift

    if [[ -n "${MYCMD_DEBUG-}" ]]; then
        # shellcheck disable=SC2312
        mycmd.log "$(mycmd.ansi bold)Calling function '${fn}':$(mycmd.ansi normal)"

        if (($# > 0)); then
            for ((i = 1; i <= "$#"; i++)); do
                mycmd.log "\targument ${i}: ${!i}"
            done
        fi

        cat - \
            | tee >(mycmd._log_input "${fn}" || true) \
            | ${fn} "$@" \
            | tee >(mycmd._log_output "${fn}" || true)
    else
        ${fn} "$@"
    fi
}

# ------------------------------------------------------------------------------
# Functions for managing caches and temporary files
case ${_MYCMD_OS} in
    Darwin)
        # https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/MacOSXDirectories/MacOSXDirectories.html#//apple_ref/doc/uid/TP40010672-CH10-SW1
        MYCMD_CACHE_DIR=${HOME}/Library/Caches/mycmd
        ;;

    Linux)
        MYCMD_CACHE_DIR=${HOME}/.cache/mycmd
        ;;

    *)
        mycmd.err_exit 1 "OS ${_MYCMD_OS} is not currently supported."
        ;;
esac
readonly MYCMD_CACHE_DIR

function mycmd._create_cache_dir_if_needed() {
    mycmd.trace "Creating cache directory ${MYCMD_CACHE_DIR} if needed."
    mkdir -p "${MYCMD_CACHE_DIR}" || {
        mycmd.err_exit 1 "Error creating MyCmd cache directory '${MYCMD_CACHE_DIR}'."
    }
}
mycmd.defer_at_startup mycmd._create_cache_dir_if_needed

# mycmd.get_named_cache_file
#   Returns the path name of a file to use for caching from a common cache directory.
#
#   These files are used for caching state in between runs of commands.
function mycmd.get_named_cache_file() {
    mycmd.err_exit 1 "TODO: Not Implemented"
}

# ------------------------------------------------------------------------------
# Convenience Methods and Data Structures Supporting MyCmd Help Output
declare -Agx _MYCMD_COMMAND_GROUP_VERSIONS=()
declare -Agx _MYCMD_COMMAND_GROUP_SHORT_DESCS=()
declare -Agx _MYCMD_COMMAND_GROUP_LONG_DESCS=()
declare -Agx _MYCMD_COMMAND_VERSIONS=()
declare -Agx _MYCMD_COMMAND_SHORT_DESCS=()
declare -Agx _MYCMD_COMMAND_HELPS=()
declare -Agx _MYCMD_COMMAND_HELP_FNS=()

function mycmd._register_value_for_calling_file() {
    if (($# < 3)); then
        mycmd._dispatch_with_calling_file_up_frames 2 "${FUNCNAME[0]}" "${@}"
        return $?
    fi

    local -r calling_file="${1}"
    local -n value_array_ref="${2}"
    local -r value="${3}"

    local command_or_group_path
    if ! command_or_group_path=$(mycmd.path_relative_to_mycmd_base "${calling_file}"); then
        mycmd.debug "Error getting command or command group path for calling file ${calling_file}."
        return 1
    fi
    readonly command_or_group_path

    mycmd.trace "Setting value in ${!value_array_ref} for calling file '${calling_file}' to '${value}'."
    # shellcheck disable=SC2034
    value_array_ref["${command_or_group_path}"]="${value}"
}

function mycmd._get_value_for_calling_file() {
    if (($# < 2)); then
        mycmd._dispatch_with_calling_file_up_frames 2 "${FUNCNAME[0]}" "${@}"
        return $?
    fi

    local -r calling_file="${1}"
    local -n get_value_array_ref="${2}"

    local command_group_path
    if ! command_group_path=$(mycmd.path_relative_to_mycmd_base "${calling_file}"); then
        mycmd.debug "Error getting command group path for calling file ${calling_file}."
        return 1
    fi
    readonly command_group_path

    if [[ -v get_value_array_ref["${command_group_path}"] ]]; then
        echo "${get_value_array_ref["${command_group_path}"]}"
        return 0
    else
        mycmd.debug "Entry not found in ${!get_value_array_ref} for ${calling_file}."
        return 1
    fi
}

function mycmd._get_value_for_calling_file_with_default() {
    if (($# < 3)); then
        mycmd._dispatch_with_calling_file_up_frames 2 "${FUNCNAME[0]}" "${@}"
        return $?
    fi

    mycmd.debug "Called with '${*}'"

    local -r calling_file="${1}"
    local -n get_value_array_ref="${2}"
    local -r default="${3}"

    local command_group_path
    if ! command_group_path=$(mycmd.path_relative_to_mycmd_base "${calling_file}"); then
        mycmd.debug "Error getting command group path for calling file ${calling_file}."
        return 1
    fi
    readonly command_group_path

    if [[ -v get_value_array_ref["${command_group_path}"] ]]; then
        echo "${get_value_array_ref["${command_group_path}"]}"
    else
        mycmd.debug "Entry not found in ${!get_value_array_ref} for ${calling_file}."
        echo "${default}"
    fi

    return 0
}

function mycmd.register_command_group_version() {
    local -r version="${1}"
    mycmd._register_value_for_calling_file \
        _MYCMD_COMMAND_GROUP_VERSIONS \
        "${version}"
}

function mycmd.register_command_group_short_desc() {
    local -r short_desc="${1}"
    mycmd._register_value_for_calling_file \
        _MYCMD_COMMAND_GROUP_SHORT_DESCS \
        "${short_desc}"
}

function mycmd.register_command_group_long_desc() {
    local -r long_desc="${1}"
    mycmd._register_value_for_calling_file \
        _MYCMD_COMMAND_GROUP_LONG_DESCS \
        "${long_desc}"
}

function mycmd.register_command_version() {
    local -r version="${1}"
    mycmd._register_value_for_calling_file \
        _MYCMD_COMMAND_VERSIONS \
        "${version}"
}

function mycmd.register_command_short_desc() {
    local -r short_desc="${1}"
    mycmd._register_value_for_calling_file \
        _MYCMD_COMMAND_SHORT_DESCS \
        "${short_desc}"
}

function mycmd.register_command_help() {
    local -r help="${1}"
    mycmd._register_value_for_calling_file \
        _MYCMD_COMMAND_HELPS \
        "${help}"
}

function mycmd.add_command_help_line() {
    local -r help_line="${1}"

    local existing_help
    if ! existing_help="$(mycmd._get_value_for_calling_file _MYCMD_COMMAND_HELPS)"; then
        existing_help=""
    fi
    readonly existing_help

    local -r new_help="${existing_help-}${existing_help:+\n}${help_line}"

    mycmd._register_value_for_calling_file \
        _MYCMD_COMMAND_HELPS \
        "${new_help}"
}

function mycmd.command_version() {
    if [[ ! -v MYCMD_COMMAND_ABSPATH ]]; then
        mycmd.log "MYCMD_COMMAND_ABSPATH not yet set; perhaps not yet executing a MyCmd Command"
        return 1
    fi

    local version
    if ! version="$(mycmd._get_value_for_calling_file_with_default "${MYCMD_COMMAND_ABSPATH}" _MYCMD_COMMAND_VERSIONS "Unknown")"; then
        mycmd.log "Error getting version for command."
        return 1
    fi
    readonly version

    local command_path
    if ! command_path="$(mycmd.running_command_parts_from_path)"; then
        mycmd.log "Error getting running command parts."
        return 1
    fi
    readonly command_path

    mycmd.output "${command_path} version ${version}"
    return 0
}

function mycmd.command_help() {
    if [[ ! -v MYCMD_COMMAND_ABSPATH ]]; then
        mycmd.log "MYCMD_COMMAND_ABSPATH not yet set; perhaps not yet executing a MyCmd Command"
        return 1
    fi

    local command_path
    if ! command_path="$(mycmd.running_command_parts_from_path)"; then
        mycmd.log "Error getting running command parts."
        return 1
    fi
    readonly command_path

    local short_desc
    if ! short_desc="$(mycmd._get_value_for_calling_file_with_default "${MYCMD_COMMAND_ABSPATH}" _MYCMD_COMMAND_SHORT_DESCS "${_MYCMD_COMMAND_DESC} ${command_path}")"; then
        mycmd.log "Error getting short description for command."
        return 1
    fi
    readonly short_desc

    mycmd.output "${command_path}\n"
    mycmd.output "${short_desc}\n"

    local help
    if help="$(mycmd._get_value_for_calling_file "${MYCMD_COMMAND_ABSPATH}" _MYCMD_COMMAND_HELPS)"; then
        mycmd.output "${help}\n"
    fi
    readonly help

    mycmd.command_version
}

function mycmd.command_group_version() {
    local -r command_group_path="${1}"
    local command_group_launcher_parts
    if ! command_group_launcher_parts="$(mycmd.command_or_group_parts_from_path "${command_group_path}" mycmd)"; then
        mycmd.log "Error getting command group parts for '${command_group_path}'."
        return 1
    fi
    readonly command_group_launcher_parts

    local command_group_name
    if ! command_group_name="$(basename "${command_group_path}")"; then
        mycmd.log "Error getting command group name for '${command_group_path}'."
        return 1
    fi
    readonly command_group_name

    local -r command_group_file_path="${command_group_path}/${command_group_name}-lib"

    local version
    if ! version="$(mycmd._get_value_for_calling_file_with_default "${command_group_file_path}" _MYCMD_COMMAND_GROUP_VERSIONS "Unknown")"; then
        mycmd.log "Error getting version for command group."
        return 1
    fi
    readonly version

    mycmd.output "${command_group_launcher_parts} version ${version}"

    return 0
}

function mycmd.command_group_help() {
    local -r command_group_path="${1}"
    local command_group_launcher_parts
    if ! command_group_launcher_parts="$(mycmd.command_or_group_parts_from_path "${command_group_path}" mycmd)"; then
        mycmd.log "Error getting command group parts for '${command_group_path}'."
        return 1
    fi
    readonly command_group_launcher_parts

    local command_group_name
    if ! command_group_name="$(basename "${command_group_path}")"; then
        mycmd.log "Error getting command group name for '${command_group_path}'."
        return 1
    fi
    readonly command_group_name

    local -r command_group_file_path="${command_group_path}/${command_group_name}-lib"

    local short_desc
    if ! short_desc="$(mycmd._get_value_for_calling_file_with_default "${command_group_file_path}" _MYCMD_COMMAND_GROUP_SHORT_DESCS "${_MYCMD_COMMAND_GROUP_DESC} ${command_group_launcher_parts}")"; then
        mycmd.log "Error getting short description for command group."
        return 1
    fi
    readonly short_desc

    mycmd.command_group_version "${command_group_path}"
    mycmd.output "\n${short_desc}\n"

    local long_desc
    if long_desc="$(mycmd._get_value_for_calling_file "${command_group_file_path}" _MYCMD_COMMAND_GROUP_LONG_DESCS)"; then
        mycmd.output "${long_desc}\n"
    fi
    readonly long_desc

    return 0
}

# ------------------------------------------------------------------------------
# Finalization and Clean Up
mycmd._protect_mycmd_lib
mycmd.source_mycmd_local_lib
mycmd.run_startup_deferreds

mycmd.trace "${_MYCMD_LIB_SELF_FILE} sourcing complete."

# -*- mode: shell-script; sh-shell: bash; sh-basic-offset: 4; sh-indentation: 4; coding: utf-8 -*-
# shellcheck shell=bash

# ------------------------------------------------------------------------------
# MyCmd Base Shell Library
#   Library to be sourced with common routines for MyCmd scripts and commands

# ------------------------------------------------------------------------------
# Basic Housekeeping
#
# Set options for safety
set -o nounset -o errexit -o errtrace -o pipefail

# This file should only be sourced and not executed directly, so exit with error
# with execution is attempted. Technique borrowed from
# https://stackoverflow.com/a/28776166
(return 0 >/dev/null 2>&1) || {
    echo >&2 "$0 is a library only meant to be sourced."
    exit 1
}

# This library should only be sourced once. Technique borrowed from
# https://stackoverflow.com/a/64534652
[[ -n "${_MYCMD_LIB-}" ]] && return
readonly _MYCMD_LIB=1

readonly _MYCMD_LIB_SELF_FILE="${BASH_SOURCE[0]}"

# _MYCMD_EARLY_SHELL_TRACE and _MYCMD_EARLY_SHELL_VERBOSE are mainly for the ease of debugging
# MyCmd itself; since the MyCmd launcher is also in shell and sources mycmd-lib, if we check
# the user facing variables MYCMD_SHELL_TRACE and MYCMD_SHELL_VERBOSE and set the options here
# the output will have too much of the mechanics of MyCmd itself and not the user's command.
[[ -n "${_MYCMD_EARLY_SHELL_TRACE-}" ]] && set -o xtrace

[[ -n "${_MYCMD_EARLY_SHELL_VERBOSE-}" ]] && set -o verbose

# ------------------------------------------------------------------------------
# Basic Logging and Output Functions
#
#   These are defined as early as possible to enable to be used through-out this
#   file. See the Additional Logging Support section below for additional
#   functionality.
#
#   In general, use these functions for any output that the user may see, and use
#   echo for interal implementation use for functions that are meant to be called
#   in sub-shells to capture output.

# These file descriptors are set up to make output easier
exec {_MYCMD_OUTPUT_FD}>&1
readonly _MYCMD_OUTPUT_FD
export _MYCMD_OUTPUT_FD

# mycmd.output
#   Convenience for runtime output to stdout. Provided for symmetry in output
#   functions.
function mycmd._output() {
    local -r output_fd="${1}"
    shift

    printf '%b\n' "$*" >&"${output_fd}"
}

# mycmd.output
#   Convenience for runtime output to stdout. Provided for symmetry in output
#   functions.
function mycmd.output() {
    mycmd._output "${_MYCMD_OUTPUT_FD}" "$*"
}

function mycmd._output_with_timestamp() {
    local -r output_fd="${1}"
    shift

    printf '[%(%F %T)T] %b\n' -1 "$*" 1>&"${output_fd}"
}

# mycmd.output_with_timestamp
#   Convenience for runtime output to stdout, with each line prefixed by the
#   current timestamp.
function mycmd.output_with_timestamp() {
    mycmd._output_with_timestamp "${_MYCMD_OUTPUT_FD}" "$*"
}

exec {_MYCMD_LOG_FD}>&2
readonly _MYCMD_LOG_FD
export _MYCMD_LOG_FD

# mycmd.log
#   Convenience for runtime logging to stderr.
function mycmd.log() {
    mycmd._output_with_timestamp "${_MYCMD_LOG_FD}" "$*" 1>&2
}

# mycmd.debug
#   Optionally log when MYCMD_DEBUG is set. Useful for debugging output.
function mycmd.debug() {
    if [[ -n "${MYCMD_DEBUG-}" ]]; then
        mycmd.log "[DEBUG] $*"
    fi
}

# mycmd.trace
#   Optionally log when MYCMD_TRACE is set. Useful for tracing script execution.
function mycmd.trace() {
    if [[ -n "${MYCMD_TRACE-}" ]]; then
        mycmd.log "[TRACE] $*"
    fi
}

# mycmd.err_exit
#   Output an error message to stderr and exit with a non-zero exit code.
#
#   $1 - Exit code to use
#   Remainder - Error message
function mycmd.err_exit() {
    local -r exit_code=$1
    shift

    mycmd.log "$*"
    exit "${exit_code}"
}

# ------------------------------------------------------------------------------
# Validate environment
function mycmd._validate_environment() {
    local mycmd_var

    for mycmd_var in "MYCMD_SYSTEM_BASE_DIR" "MYCMD_USER_BASE_DIR" "MYCMD_VENDOR_DIR"; do
        if [[ -z "${!mycmd_var-}" ]]; then
            mycmd.err_exit 1 "Required environment variable ${mycmd_var} is not set."
        fi
    done
}

mycmd._validate_environment

# ------------------------------------------------------------------------------
# Vendor Library Support
function mycmd.load_vendor_library() {
    local -r vendor_library="${1}"
    # shellcheck disable=SC2154
    local -r vendor_library_path="${MYCMD_VENDOR_DIR}/${vendor_library}"

    if [[ -e "${vendor_library_path}" ]]; then
        mycmd.trace "Loading vendored library '${vendor_library}'."
        # shellcheck source=/dev/null
        source "${vendor_library_path}"
    else
        mycmd.log "Vendored library '${vendor_library}' not found."
        return 1
    fi
}

# ------------------------------------------------------------------------------
# Event Handling Support
if ! mycmd.load_vendor_library "bashup.events"; then
    mycmd.err_exit 1 "Required library missing."
fi

# mycmd.event
#   Simple wrapper around bashup.event to present a consistent
#   interface to MyCmd command implementors.
function mycmd.event() {
    event "${@}"
}

# -------------------------------------------------------------------------------
# Library Deferred Commands Support
#
#   Commands to run after all libraries are sourced

# mycmd._dispatch_with_calling_file
#   Higher order function that passes the full pathname of the shell file that called the
#   function that called  mycmd._dispatch_with_calling_file as the first parameter of the
#   function.
function mycmd._dispatch_with_calling_file() {
    local -r fn=$1
    shift

    local calling_file
    # stack frame 0 - who called me
    # stack frame 1 - who called that
    read -r _ _ calling_file <<<"$(caller 1 || true)"
    # TODO: Do I need to get an abspath?
    readonly calling_file
    mycmd.trace "Dispatching with calling file '${calling_file}'"

    "${fn}" "${calling_file}" "${@}"
}

function mycmd._get_file_startup_event_name() {
    local -r calling_file=${1}
    local -r event_name="${1}:mycmd_startup"

    echo "${event_name}"
}

function mycmd._defer_at_startup() {
    local -r calling_file="${1}"
    shift

    local event_name
    if ! event_name="$(mycmd._get_file_startup_event_name "${calling_file}")"; then
        mycmd.log "Error getting file startup event name"
        return 1
    fi
    readonly event_name

    mycmd.event on "${event_name}" "${@}"
}

# mycmd.defer_at_startup
#  Called with a command to call at the end of evaluating the library.
#
#  These commands are explicitly called by the explicit call to
#  mycmd.run_startup_deferreds at the end of this file.
function mycmd.defer_at_startup() {
    mycmd._dispatch_with_calling_file mycmd._defer_at_startup "${@}"
}

# mycmd.run_startup_deferreds
#   Supports two calling mechanism: one by the library explicitly, like from
#   this file. Or another on behalf of another file.
#
#   A quirk of how mycmd._dispatch_with_calling_file works allows us to be
#   recursive here
# shellcheck disable=SC2120
function mycmd.run_startup_deferreds() {
    if (($# < 1)); then
        mycmd._dispatch_with_calling_file "${FUNCNAME[0]}"
        return $?
    fi

    local -r calling_file="${1}"
    mycmd.trace "Calling deferred startup events for ${calling_file}."

    local event_name
    if ! event_name="$(mycmd._get_file_startup_event_name "${calling_file}")"; then
        mycmd.log "Error getting file startup event name"
        return 1
    fi
    readonly event_name

    if mycmd.event has "${event_name}"; then
        mycmd.trace "Calling deferred startup events for ${calling_file}."
        mycmd.event fire "${event_name}"
    fi
}

# -------------------------------------------------------------------------------
# Library clean up commands support
#   Basic clean up and error handling commands
readonly _MYCMD_EXIT_EVENT="mycmd_exit"

function mycmd.defer_at_exit() {
    mycmd.event on "${_MYCMD_EXIT_EVENT}" "${@}"
}

function mycmd._print_stack_trace() {
    mycmd.trace "Running ${FUNCNAME[0]}, with args '$*'"

    # Disable the trap
    trap - ERR

    # Method borrowed from https://raimonster.com/scripting-field-guide/#org3417a0c
    local return_code=$1

    ((return_code == 0)) && return 0

    mycmd.log "\nThe command ${BASH_COMMAND} triggered a stack trace."

    local -i i
    local -i j

    for i in $(seq 1 $((${#FUNCNAME[@]} - 2))); do
        j=$((i + 1))
        mycmd.log "\t ${BASH_SOURCE[${i}]}: ${FUNCNAME[${i}]}() called in ${BASH_SOURCE[${j}]}:${BASH_LINENO[${i}]}"
    done
}

function mycmd._run_at_exit_deferreds() {
    # Disable the trap handler, including ERR here just in case, as this should be run last
    trap - SIGINT SIGTERM ERR EXIT

    if mycmd.event has "${_MYCMD_EXIT_EVENT}"; then
        mycmd.trace "Calling deferred at exit events."
        mycmd.event fire "${_MYCMD_EXIT_EVENT}"
    fi

    mycmd.trace "All at exit deferreds execution completed."
}

trap 'mycmd._print_stack_trace $?' ERR
trap mycmd._run_at_exit_deferreds SIGINT SIGTERM EXIT

# ------------------------------------------------------------------------------
# Library Protection
function mycmd.protect_library_functions() {
    local -a library_functions
    # shellcheck disable=SC2312
    readarray -t library_functions < <(compgen -A function | grep "^mycmd\.")

    local f
    for f in "${library_functions[@]}"; do
        mycmd.log "Marking function '${f}' read-only."
        readonly -f "${f}"
    done
}

mycmd.defer_at_startup mycmd.protect_library_functions

# ------------------------------------------------------------------------------
# Convenience methods for calling functions

# mycmd.function_exists
#   Test whether the specified shell function has been defined
function mycmd.function_exists() {
    declare -F "$1" >/dev/null
}

# mycmd.call_if_function_exists
#  	If the named function exists, call with the subsequent arguments. Otherwise,
#  	do nothing.
function mycmd.call_if_function_exists() {
    local -r fn=$1
    shift

    if mycmd.function_exists "${fn}"; then
        "${fn}" "$@"
    fi
}

# ------------------------------------------------------------------------------
# Convenience methods for locating common utilities cross platform

# MYCMD_BIN
#   An associative array used for dependencies that are in different
#   locations and/or names depending on the platform or host a script is
#   being run on.
#
#     Keys:  command names
#     Value: the path of the given command
declare -Ax MYCMD_BIN

# mycmd._locate_bin
#   Attempt to find the given command on the PATH. If found, return the full path.
function mycmd._locate_bin() {
    local -r command=$1
    local command_path

    if command_path=$(command -v "${command}" 2>/dev/null); then
        echo "${command_path}"
    else
        return 1
    fi
}

function mycmd.init_bin_homebrew() {
    local -r command=$1
    local -r exe_name=$2
    local -r long_name=$3
    local -r homebrew_package=$4

    local exe_path
    if exe_path=$(mycmd._locate_bin "${exe_name}"); then
        MYCMD_BIN[${command}]="${exe_path}"
    else
        mycmd.err_exit 1 "Unable to locate ${long_name}, please install from Homebrew with 'brew install ${homebrew_package}'"
    fi
}

# mycmd.init_bin
#  If not already set, attempt to set MYCMD_BIN for the given command name. Will
#  first call mycmd_local.init_bin, if the user has defined mycmd-local-lib, and
#  use the value from there as an override.
#
#  Common commands like sed, which require a different name if using GNU set installed
#  from HomeBrew on Mac OS, are included here.
#
#  It is intended that when this function is callled, the command is a required
#  dependency and thus this will exit with an error if the command cannot be found.
function mycmd.init_bin() {
    local -r command=$1

    mycmd.call_if_function_exists mycmd_local.init_bin "$@"

    [[ -v MYCMD_BIN["${command}"] ]] && {
        mycmd.debug "'${command}' already defined at '${MYCMD_BIN[${command}]}'"
        return 0
    }

    local command_path

    case "${command}+${_MYCMD_OS}" in
        "awk+Darwin")
            mycmd.init_bin_homebrew awk gawk "GNU awk" gawk
            ;;
        "find+Darwin")
            mycmd.init_bin_homebrew find gfind "GNU find" findutils
            ;;
        "realpath+Darwin")
            mycmd.init_bin_homebrew realpath grealpath "GNU realpath" coreutils
            ;;
        "sed+Darwin")
            mycmd.init_bin_homebrew sed gsed "GNU Sed" "gnu-sed"
            ;;
        "stat+Darwin")
            mycmd.init_bin_homebrew sed gstat "GNU Stat" coreutils
            ;;
        "wc+Darwin")
            mycmd.init_bin_homebrew wc gwc "GNU wc" coreutils
            ;;
        "sha1sum+Darwin")
            local shasum_path
            # shasum is the implementation that ships with mac OS. SHA1 is the default algorithm so it is
            # a drop in for most cases
            if shasum_path=$(mycmd._locate_bin shasum); then
                MYCMD_BIN[${command}]="${shasum_path}"
            else
                mycmd.err_exit 1 "Unable to locate shasum"
            fi
            ;;
        *)
            if command_path=$(mycmd._locate_bin "${command}"); then
                MYCMD_BIN[${command}]="${command_path}"
            else
                mycmd.err_exit 1 "Unable to locate path for '${command}'."
            fi
            ;;

    esac
}

# -------------------------------------------------------------------------------
# MyCmd Operating System Support
#   Common variables set according to OS being run on.
_MYCMD_OS="$(uname -s)"
readonly _MYCMD_OS



# ------------------------------------------------------------------------------
# Functions for managing caches and temporary files
case ${_MYCMD_OS} in
    Darwin)
        # https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/MacOSXDirectories/MacOSXDirectories.html#//apple_ref/doc/uid/TP40010672-CH10-SW1
        MYCMD_CACHE_DIR=${HOME}/Library/Caches/mycmd
        ;;

    Linux)
        MYCMD_CACHE_DIR=${HOME}/.cache/mycmd
        ;;

    *)
        mycmd.err_exit 1 "OS ${_MYCMD_OS} is not currently supported."
        ;;
esac
readonly MYCMD_CACHE_DIR

function mycmd._create_cache_dir_if_needed() {
    mycmd.trace "Creating cache directory ${MYCMD_CACHE_DIR} if needed."
    mkdir -p "${MYCMD_CACHE_DIR}" || {
        mycmd.err_exit 1 "Error creating MyCmd cache directory '${MYCMD_CACHE_DIR}'."
    }
}
mycmd.defer_at_startup mycmd._create_cache_dir_if_needed

# mycmd.get_named_cache_file
#   Returns the path name of a file to use for caching from a common cache directory.
#
#   These files are used for caching state in between runs of commands.
mycmd.defer_at_startup mycmd.init_bin realpath
function mycmd.get_named_cache_file() {
    if (($# < 1)); then
        mycmd.log "Missing required parameter CACHE_FILE_NAME to mycmd.get_named_cache_file."
        return 1
    fi

    local -r cache_file_name=$1
    local running_cmd_relative_path
    if ! running_cmd_relative_path="$(mycmd.running_cmd_relative_path)"; then
        mycmd.log "Error getting cmd relative path"
        return 1
    fi
    readonly running_cmd_relative_path

    local running_cmd_name
    if ! running_cmd_name="$(mycmd.running_cmd_name)"; then
        mycmd.log "Error getting running cmd name"
        return 1
    fi
    readonly running_cmd_name

    local cmd_base_cache_dir
    cmd_base_cache_dir="${MYCMD_CACHE_DIR}/${running_cmd_relative_path}/${running_cmd_name}"
    cmd_base_cache_dir="$("${MYCMD_BIN[realpath]}" -m "${cmd_base_cache_dir}")"
    readonly cmd_base_cache_dir

    # TODO: Do we want to change the permissions on the cache directory?
    mkdir -p "${cmd_base_cache_dir}"

    local named_cache_file
    named_cache_file="${cmd_base_cache_dir}/${cache_file_name}"
    named_cache_file="$("${MYCMD_BIN[realpath]}" -m "${named_cache_file}")"
    readonly named_cache_file

    echo "${named_cache_file}"
}

# ------------------------------------------------------------------------------
# Finalization and Clean Up
mycmd.run_startup_deferreds

mycmd.trace "${_MYCMD_LIB_SELF_FILE} sourcing complete."

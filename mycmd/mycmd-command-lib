# -*- mode: shell-script; sh-shell: bash; sh-basic-offset: 4; sh-indentation: 4; coding: utf-8 -*-
# shellcheck shell=bash

# MyCmd Command Support Library
#   Support for Command Data Structures and Related Functions for MyCmd

set -o nounset -o errexit -o errtrace -o pipefail

(return 0 >/dev/null 2>&1) || {
    echo >&2 "$0 is a library only meant to be sourced."
    exit 1
}

[[ -n "${_MYCMD_COMMAND_LIB:-}" ]] && return
readonly _MYCMD_COMMAND_LIB=1

if [[ ! -v _MYCMD_LIB_DIR ]]; then
    readonly _MYCMD_COMMAND_LIB_SELF_FILE="${BASH_SOURCE[0]}"
    _MYCMD_LIB_DIR=$(cd "$(dirname "${_MYCMD_COMMAND_LIB_SELF_FILE}")" &>/dev/null && pwd -P)
    readonly _MYCMD_LIB_DIR
fi

# ------------------------------------------------------------------------------
# Source Required Support Libraries
if [[ ! -v _MYCMD_LOADING_LIB ]]; then
    # shellcheck source=./mycmd-loading-lib
    source "${_MYCMD_LIB_DIR}/mycmd-loading-lib"
fi

mycmd.load_mycmd_lib_support_lib "event-lifecycle"
mycmd.load_mycmd_lib_support_lib "function-calling"
mycmd.load_mycmd_lib_support_lib "output"
mycmd.load_mycmd_lib_support_lib "pathname"

# A Command has:
# - A Name:  chase-visa
# - A Fully Qualified Name for Containing Command Group - 'mycmd/financial/import'
# - A Fully Qualifield Name - `mycmd/financial/import/chase-visa`
# - Namespaced Parts - [mycmd, financial, import, chase-visa  ]
# - A Source File - $HOME/mycmd/financial/import/chase-visa
# - A short description used in help
# - A long description used in help
# - A version string used in help

# Global Data Structures
# - All registered Commands
declare -agx _MYCMD_COMMANDS=()
# The rest all all keyed by the fully qualified name
# - Command Group Source Files
declare -Agx _MYCMD_COMMAND_SOURCE_FILES=()
# - Command Group Short Descriptions
declare -Agx _MYCMD_COMMAND_SHORT_DESCS=()
# - Command Group Long Descriptions
declare -Agx _MYCMD_COMMAND_LONG_DESCS=()
# - Command Group Versions
declare -Agx _MYCMD_COMMAND_VERSIONS=()
# - Commands with fully loaded metadata
declare -Agx _MYCMD_COMMAND_METADATA_LOADED=()

# Command Data Structure
readonly _COMMAND_NAME_FIELD='command-name'
readonly _COMMAND_FULLY_QUALIFIED_NAME_FIELD='command-fully-qualified-name'
readonly _COMMAND_FULLY_QUALIFIED_COMMAND_GROUP_NAME_FIELD='command-fully-qualified-command-group-name'
readonly _COMMAND_SOURCE_FILE_FIELD='command-source-file'
readonly _COMMAND_SHORT_DESC_FIELD='command-short-description'
readonly _COMMAND_LONG_DESC_FIELD='command-long-description'
readonly _COMMAND_VERSION_FIELD='command-version'
readonly _COMMAND_METADATA_LOADED_FIELD='command-metadata-loaded'

function mycmd:command.file_is_command() {
    local -r potential_command="${1}"

    if ! mycmd:pathname.is_valid_absolute_path_of_executable_file "${potential_command}"; then
        mycmd.debug "'${potential_command}' is not a valid absolute path of an executable file."
        return 1
    fi

    if mycmd.is_called_by_function "mycmd:pathname.walk_path"; then
        mycmd.trace "Skipping validation of file is on MyCmd Search path, assuming it is, as called from 'mycmd:pathname.walk_path'."
    else
        if ! mycmd:pathname.is_child_of_mycmd_path_directory "${potential_command}"; then
            mycmd.debug "'${potential_command}' is not located on the MyCmd Search Path."
            return 1
        fi
    fi

    return 0
}

function mycmd:command.register_version() {
    if [[ ! -v _MYCMD_SOURCING_COMMAND_FOR_HELP && ! -v _MYCMD_COMMAND_FULLY_QUALIFIED_NAME ]]; then
        mycmd.debug "Error: _MYCMD_SOURCING_COMMAND_FOR_HELP and _MYCMD_COMMAND_FULLY_QUALIFIED_NAME must be set."
        return 1
    fi

    local -r version="${1}"
    _MYCMD_COMMAND_VERSIONS["${_MYCMD_COMMAND_FULLY_QUALIFIED_NAME}"]="${version}"

    return 0
}

function mycmd:command.register_short_description() {
    if [[ ! -v _MYCMD_SOURCING_COMMAND_FOR_HELP && ! -v _MYCMD_COMMAND_FULLY_QUALIFIED_NAME ]]; then
        mycmd.debug "Error: _MYCMD_SOURCING_COMMAND_FOR_HELP and _MYCMD_COMMAND_FULLY_QUALIFIED_NAME must be set."
        return 1
    fi

    local -r short_description="${1}"
    _MYCMD_COMMAND_SHORT_DESCS["${_MYCMD_COMMAND_FULLY_QUALIFIED_NAME}"]="${short_description}"

    return 0
}

function mycmd:command.register_long_description() {
    if [[ ! -v _MYCMD_SOURCING_COMMAND_FOR_HELP && ! -v _MYCMD_COMMAND_FULLY_QUALIFIED_NAME ]]; then
        mycmd.debug "Error: _MYCMD_SOURCING_COMMAND_FOR_HELP and _MYCMD_COMMAND_FULLY_QUALIFIED_NAME must be set."
        return 1
    fi

    local -r long_description="${1}"
    _MYCMD_COMMAND_LONG_DESCS["${_MYCMD_COMMAND_FULLY_QUALIFIED_NAME}"]="${long_description}"

    return 0
}

function mycmd:command.register_command() {
    local -r potential_command="${1}"
    local -r fully_qualifed_name="${2}"

    if ! mycmd:command.file_is_command "${potential_command}"; then
        mycmd.debug "'${potential_command}' is not a valid command."
        return 0
    fi

    if [[ -v _MYCMD_COMMAND_SOURCE_FILES[${fully_qualifed_name}] ]]; then
        if [[ "${_MYCMD_COMMAND_SOURCE_FILES[${fully_qualifed_name}]}" != "${potential_command}" ]]; then
            mycmd.debug "Command '${fully_qualifed_name}' has already been registered with a different source file."
            return 1
        else
            mycmd.debug "Command '${fully_qualifed_name}' has already been registered."
            return 0
        fi
    fi

    # TODO - Validate enclosing command groups are registered
    _MYCMD_COMMAND_SOURCE_FILES["${fully_qualifed_name}"]="${potential_command}"
    _MYCMD_COMMANDS+=("${fully_qualifed_name}")

    return 0
}

function mycmd:command.get_command() {
    local -r command_fq_name="${1}"
    local -n command_struct_ref="${2}"

    if [[ ! -v _MYCMD_COMMAND_SOURCE_FILES[${command_fq_name}] ]]; then
        mycmd.log "Unknown command: '${command_fq_name}'."
        return 1
    fi

    mycmd.trace "Returning Command definition:"
    command_struct_ref["${_COMMAND_NAME_FIELD}"]="$(basename "${command_fq_name}")"
    mycmd.trace "- ${_COMMAND_NAME_FIELD}: ${command_struct_ref["${_COMMAND_NAME_FIELD}"]}"

    command_struct_ref["${_COMMAND_FULLY_QUALIFIED_NAME_FIELD}"]="${command_fq_name}"
    mycmd.trace "- ${_COMMAND_FULLY_QUALIFIED_NAME_FIELD}: ${command_struct_ref["${_COMMAND_FULLY_QUALIFIED_NAME_FIELD}"]}"

    command_struct_ref["${_COMMAND_FULLY_QUALIFIED_COMMAND_GROUP_NAME_FIELD}"]="$(dirname "${command_fq_name}")"
    mycmd.trace "- ${_COMMAND_FULLY_QUALIFIED_COMMAND_GROUP_NAME_FIELD}: ${command_struct_ref["${_COMMAND_FULLY_QUALIFIED_COMMAND_GROUP_NAME_FIELD}"]}"

    command_struct_ref["${_COMMAND_SOURCE_FILE_FIELD}"]="${_MYCMD_COMMAND_SOURCE_FILES["${command_fq_name}"]}"
    mycmd.trace "- ${_COMMAND_SOURCE_FILE_FIELD}: ${command_struct_ref["${_COMMAND_SOURCE_FILE_FIELD}"]}"

    if [[ -v _MYCMD_COMMAND_SHORT_DESCS[${command_fq_name}] ]]; then
        command_struct_ref["${_COMMAND_SHORT_DESC_FIELD}"]="${_MYCMD_COMMAND_SHORT_DESCS["${command_fq_name}"]}"
        mycmd.trace "- ${_COMMAND_SHORT_DESC_FIELD}: ${command_struct_ref["${_COMMAND_SHORT_DESC_FIELD}"]}"
    else
        mycmd.trace "- ${_COMMAND_SHORT_DESC_FIELD}: No value set."
    fi

    if [[ -v _MYCMD_COMMAND_LONG_DESCS[${command_fq_name}] ]]; then
        command_struct_ref["${_COMMAND_LONG_DESC_FIELD}"]="${_MYCMD_COMMAND_LONG_DESCS["${command_fq_name}"]}"
        mycmd.trace "- ${_COMMAND_LONG_DESC_FIELD}: ${command_struct_ref["${_COMMAND_LONG_DESC_FIELD}"]}"
    else
        mycmd.trace "- ${_COMMAND_LONG_DESC_FIELD}: No value set."
    fi

    if [[ -v _MYCMD_COMMAND_VERSIONS[${command_fq_name}] ]]; then
        command_struct_ref["${_COMMAND_VERSION_FIELD}"]="${_MYCMD_COMMAND_VERSIONS["${command_fq_name}"]}"
        mycmd.trace "- ${_COMMAND_VERSION_FIELD}: ${command_struct_ref["${_COMMAND_VERSION_FIELD}"]}"
    else
        mycmd.trace "- ${_COMMAND_VERSION_FIELD}: No value set."
    fi

    if [[ -v _MYCMD_COMMAND_METADATA_LOADED[${command_fq_name}] ]]; then
        command_struct_ref["${_COMMAND_METADATA_LOADED_FIELD}"]=1
        mycmd.trace "- Command metadata has been loaded."
    else
        command_struct_ref["${_COMMAND_METADATA_LOADED_FIELD}"]=0
        mycmd.trace "- Command metadata has not been loaded."
    fi
}

function mycmd:command._load_command_help_and_version() {
    local -r command_fq_name="${1}"
    local -r source_file_path="${2}"

    mycmd.trace "Loading command help and version for '${command_fq_name}' from '${source_file_path}'."

    declare -gx _MYCMD_COMMAND_FULLY_QUALIFIED_NAME="${command_fq_name}"
    declare -gx _MYCMD_SOURCING_COMMAND_FOR_HELP=1
    if ! mycmd.source_lib_by_path_if_found "${source_file_path}"; then
        mycmd.debug "Error loading command source file '${source_file_path}'."
        return 1
    fi
    unset _MYCMD_SOURCING_COMMAND_FOR_HELP
    unset _MYCMD_COMMAND_FULLY_QUALIFIED_NAME

    _MYCMD_COMMAND_METADATA_LOADED["${command_fq_name}"]=1

    return 0
}

function mycmd:command.load_command_help_and_version() {
    # shellcheck disable=SC2178
    local -n command_struct_ref="${1}"

    local command_fq_name
    command_fq_name="$(mycmd:command.get_fully_qualified_name "${!command_struct_ref}")"
    readonly command_fq_name

    local source_file_path
    source_file_path="$(mycmd:command.get_source_file "${!command_struct_ref}")"
    readonly source_file_path

    if ! mycmd:command.is_metadata_loaded "${!command_struct_ref}"; then
        mycmd.trace "Command metadata has not been loaded, so loading on demand."

        if ! mycmd:command._load_command_help_and_version "${command_fq_name}" "${source_file_path}"; then
            mycmd.debug "Error loading command help and version for '${command_fq_name}'."
            return 1
        fi

        # Reload the command struct to get the updated metadata
        mycmd:command.get_command "${command_fq_name}" "${!command_struct_ref}"
    fi

    return 0
}

function mycmd:command.execute() {
    # shellcheck disable=SC2178
    local -n command_struct_ref="${1}"
    shift

    # Source the source file

    # Get the containing command group

    # Source the command group

    # Validate that mycmd.main exists

    # Call it and exit with the return value
}

function mycmd:command._get_required_field_from_command_struct() {
    local -r field_name="${1}"
    # shellcheck disable=SC2178
    local -n command_struct_ref="${2}"

    echo "${command_struct_ref["${field_name}"]}"
}

function mycmd:command.is_metadata_loaded() {
    local is_metadata_loaded
    if ! is_metadata_loaded="$(mycmd:command._get_required_field_from_command_struct \
        "${_COMMAND_METADATA_LOADED_FIELD}" \
        "${@}")"; then
        mycmd.debug "Error getting metadata loaded field from command."
        return 1
    fi
    readonly is_metadata_loaded

    [[ "${is_metadata_loaded}" == "1" ]]
}

function mycmd:command._get_optional_field_from_command_struct() {
    local -r field_name="${1}"
    # shellcheck disable=SC2178
    local -n command_struct_ref="${2}"

    if ! mycmd:command.load_command_help_and_version "${!command_struct_ref}"; then
        mycmd.debug "Error loading command help and version for '${!command_struct_ref}'."
        return 1
    fi

    if [[ -v command_struct_ref["${field_name}"] ]]; then
        echo "${command_struct_ref["${field_name}"]}"
        return 0
    else
        local command_fq_name
        command_fq_name="$(mycmd:command.get_fully_qualified_name "${!command_struct_ref}")"
        readonly command_fq_name
        mycmd.trace "No value for '${field_name}' defined for command '${command_fq_name}'."
        return 1
    fi
}

function mycmd:command.get_name() {
    mycmd:command._get_required_field_from_command_struct \
        "${_COMMAND_NAME_FIELD}" \
        "${@}"
}

function mycmd:command.get_fully_qualified_name() {
    mycmd:command._get_required_field_from_command_struct \
        "${_COMMAND_FULLY_QUALIFIED_NAME_FIELD}" \
        "${@}"
}

function mycmd:command.get_namespaced_parts_as_string() {
    local fully_qualified_name
    fully_qualified_name="$(mycmd:command.get_fully_qualified_name "${@}")"
    readonly fully_qualified_name

    local -r namespaced_parts="${fully_qualified_name//\// }"
    echo "${namespaced_parts}"
}

function mycmd:command.get_fully_qualified_command_group_name() {
    mycmd:command._get_required_field_from_command_struct \
        "${_COMMAND_FULLY_QUALIFIED_COMMAND_GROUP_NAME_FIELD}" \
        "${@}"
}

function mycmd:command.get_source_file() {
    mycmd:command._get_required_field_from_command_struct \
        "${_COMMAND_SOURCE_FILE_FIELD}" \
        "${@}"
}

function mycmd:command.get_short_description() {
    local short_description

    if short_description="$(mycmd:command._get_optional_field_from_command_struct \
        "${_COMMAND_SHORT_DESC_FIELD}" \
        "${@}")"; then
        readonly short_description
    else
        local namespaced_parts
        namespaced_parts="$(mycmd:command.get_namespaced_parts_as_string "${@}")"
        readonly namespaced_parts
        short_description="MyCmd Command ${namespaced_parts}"
        readonly short_description
    fi

    echo "${short_description}"
    return 0
}

function mycmd:command.get_long_description() {
    mycmd:command._get_optional_field_from_command_struct \
        "${_COMMAND_LONG_DESC_FIELD}" \
        "${@}"
}

function mycmd:command.get_version() {
    local version

    if version="$(mycmd:command._get_optional_field_from_command_struct \
        "${_COMMAND_VERSION_FIELD}" \
        "${@}")"; then
        echo "${version}"
        return 0
    else
        echo "Unknown"
        return 0
    fi
}

function mycmd:command.is_source_loaded() {
    local -n command_struct_ref="${1}"
    local source_file
    if ! source_file="$(mycmd:command.get_source_file "${@}")"; then
        return 1
    fi
    readonly source_file

    mycmd._file_has_been_loaded "${source_file}"
}

function mycmd:command.get_child_commands_for_command_group() {
    local -r command_group_fully_qualified_name="${1}"
    local -n commands_array_ref="${2}"

    # shellcheck disable=SC2034
    readarray -t commands_array_ref < \
        <(printf '%s\n' "${_MYCMD_COMMANDS[@]}" \
            | grep -E "^${command_group_fully_qualified_name}/[^/]+$" \
            | LC_ALL=en_US.UTF-8 sort || true)

    return 0
}

mycmd.trace "The MyCmd Command support library has been sourced."

# -*- mode: shell-script; sh-shell: bash; sh-basic-offset: 4; sh-indentation: 4; coding: utf-8 -*-
# shellcheck shell=bash

# MyCmd Command Support Library
#   Support for Command Data Structures and Related Functions for MyCmd

set -o nounset -o errexit -o errtrace -o pipefail

(return 0 >/dev/null 2>&1) || {
    echo >&2 "$0 is a library only meant to be sourced."
    exit 1
}

[[ -n "${_MYCMD_COMMAND_LIB:-}" ]] && return
readonly _MYCMD_COMMAND_LIB=1

if [[ ! -v _MYCMD_LIB_DIR ]]; then
    readonly _MYCMD_COMMAND_LIB_SELF_FILE="${BASH_SOURCE[0]}"
    _MYCMD_LIB_DIR=$(cd "$(dirname "${_MYCMD_COMMAND_LIB_SELF_FILE}")" &>/dev/null && pwd -P)
    readonly _MYCMD_LIB_DIR
fi

# ------------------------------------------------------------------------------
# Source Required Support Libraries

if [[ ! -v _MYCMD_LOADING_LIB ]]; then
    # shellcheck source=./mycmd-loading-lib
    source "${_MYCMD_LIB_DIR}/mycmd-loading-lib"
fi

mycmd.load_mycmd_lib_support_lib "event-lifecycle"
mycmd.load_mycmd_lib_support_lib "function-calling"
mycmd.load_mycmd_lib_support_lib "output"

# A Command has:
# - A Name:  chase-visa
# - A Fully Qualified Name for Containing Command Group - 'mycmd/financial/import'
# - A Fully Qualifield Name - `mycmd/financial/import/chase-visa`
# - Namespaced Parts - [mycmd, financial, import, chase-visa  ]
# - A Source File - $HOME/mycmd/financial/import/chase-visa
# - A short description used in help
# - A long description used in help
# - A version string used in help

# Global Data Structures, all keyed by the fully qualified name
# - Command Group Source Files
declare -Agx _MYCMD_COMMAND_SOURCE_FILES=()
# - Command Group Short Descriptions
declare -Agx _MYCMD_COMMAND_SHORT_DESCS=()
# - Command Group Long Descriptions
declare -Agx _MYCMD_COMMAND_LONG_DESCS=()
# - Command Group Versions
declare -Agx _MYCMD_COMMAND_VERSIONS=()

# Command Data Structure
readonly _COMMAND_NAME_FIELD='command-name'
readonly _COMMAND_FULLY_QUALIFIED_NAME_FIELD='command-fully-qualified-name'
readonly _COMMAND_FULLY_QUALIFIED_COMMAND_GROUP_NAME_FIELD='command-fully-qualified-command-group-name'
readonly _COMMAND_SOURCE_FILE_FIELD='command-source-file'
readonly _COMMAND_SHORT_DESC_FIELD='command-short-description'
readonly _COMMAND_LONG_DESC_FIELD='command-long-description'
readonly _COMMAND_VERSION_FIELD='command-version'

function mycmd:command.get_command() {
    local -r command_fq_name="${1}"
    local -n command_struct_ref="${2}"

    if [[ ! -v _MYCMD_COMMAND_SOURCE_FILES[${command_fq_name}] ]]; then
        mycmd.log "Unknown command: '${command_fq_name}'."
        return 1
    fi

    mycmd.trace "Returning Command definition:"
    command_struct_ref["${_COMMAND_NAME_FIELD}"]="$(basename "${command_fq_name}")"
    mycmd.trace "- ${_COMMAND_NAME_FIELD}: ${command_struct_ref["${_COMMAND_NAME_FIELD}"]}"

    command_struct_ref["${_COMMAND_FULLY_QUALIFIED_NAME_FIELD}"]="${command_fq_name}"
    mycmd.trace "- ${_COMMAND_FULLY_QUALIFIED_NAME_FIELD}: ${command_struct_ref["${_COMMAND_FULLY_QUALIFIED_NAME_FIELD}"]}"

    command_struct_ref["${_COMMAND_FULLY_QUALIFIED_COMMAND_GROUP_NAME_FIELD}"]="$(dirname "${command_fq_name}")"
    mycmd.trace "- ${_COMMAND_FULLY_QUALIFIED_COMMAND_GROUP_NAME_FIELD}: ${command_struct_ref["${_COMMAND_FULLY_QUALIFIED_COMMAND_GROUP_NAME_FIELD}"]}"

    command_struct_ref["${_COMMAND_SOURCE_FILE_FIELD}"]="${_MYCMD_COMMAND_SOURCE_FILES["${command_fq_name}"]}"
    mycmd.trace "- ${_COMMAND_SOURCE_FILE_FIELD}: ${command_struct_ref["${_COMMAND_SOURCE_FILE_FIELD}"]}"

    if [[ -v _MYCMD_COMMAND_SHORT_DESCS[${command_fq_name}] ]]; then
        command_struct_ref["${_COMMAND_SHORT_DESC_FIELD}"]="${_MYCMD_COMMAND_SHORT_DESCS["${command_fq_name}"]}"
        mycmd.trace "- ${_COMMAND_SHORT_DESC_FIELD}: ${command_struct_ref["${_COMMAND_SHORT_DESC_FIELD}"]}"
    else
        mycmd.trace "- ${_COMMAND_SHORT_DESC_FIELD}: No value set."
    fi

    if [[ -v _MYCMD_COMMAND_LONG_DESCS[${command_fq_name}] ]]; then
        command_struct_ref["${_COMMAND_LONG_DESC_FIELD}"]="${_MYCMD_COMMAND_LONG_DESCS["${command_fq_name}"]}"
        mycmd.trace "- ${_COMMAND_LONG_DESC_FIELD}: ${command_struct_ref["${_COMMAND_LONG_DESC_FIELD}"]}"
    else
        mycmd.trace "- ${_COMMAND_LONG_DESC_FIELD}: No value set."
    fi

    if [[ -v _MYCMD_COMMAND_VERSIONS[${command_fq_name}] ]]; then
        command_struct_ref["${_COMMAND_VERSION_FIELD}"]="${_MYCMD_COMMAND_VERSIONS["${command_fq_name}"]}"
        mycmd.trace "- ${_COMMAND_VERSION_FIELD}: ${command_struct_ref["${_COMMAND_VERSION_FIELD}"]}"
    else
        mycmd.trace "- ${_COMMAND_VERSION_FIELD}: No value set."
    fi
}

function mycmd:command.execute() {
    # shellcheck disable=SC2178
    local -n command_struct_ref="${1}"
    shift

    # Source the source file

    # Get the containing command group

    # Source the command group

    # Validate that mycmd.main exists

    # Call it and exit with the return value
}

function mycmd:command._get_required_field_from_command_struct() {
    local -r field_name="${1}"
    # shellcheck disable=SC2178
    local -n command_struct_ref="${2}"

    echo "${command_struct_ref["${field_name}"]}"
}

function mycmd:command._get_optional_field_from_command_struct() {
    local -r field_name="${1}"
    # shellcheck disable=SC2178
    local -n command_struct_ref="${2}"

    if [[ -v command_struct_ref["${field_name}"] ]]; then
        echo "${command_struct_ref["${field_name}"]}"
        return 0
    else
        local command_fq_name
        command_fq_name="$(mycmd:command.get_fully_qualified_name "${!command_struct_ref}")"
        readonly command_fq_name
        mycmd.trace "No value for '${field_name}' defined for command '${command_fq_name}'."
        return 1
    fi
}

function mycmd:command.get_name() {
    mycmd:command._get_required_field_from_command_struct \
        "${_COMMAND_NAME_FIELD}" \
        "${@}"
}

function mycmd:command.get_fully_qualified_name() {
    mycmd:command._get_required_field_from_command_struct \
        "${_COMMAND_FULLY_QUALIFIED_NAME_FIELD}" \
        "${@}"
}

function mycmd:command.get_namespaced_parts_as_string() {
    local fully_qualified_name
    fully_qualified_name="$(mycmd:command.get_fully_qualified_name "${@}")"
    readonly fully_qualified_name

    local -r namespaced_parts="${fully_qualified_name//\// }"
    echo "${namespaced_parts}"
}

function mycmd:command.get_fully_qualified_command_group_name() {
    mycmd:command._get_required_field_from_command_struct \
        "${_COMMAND_FULLY_QUALIFIED_COMMAND_GROUP_NAME_FIELD}" \
        "${@}"
}

function mycmd:command.get_source_file() {
    mycmd:command._get_required_field_from_command_struct \
        "${_COMMAND_SOURCE_FILE_FIELD}" \
        "${@}"
}

function mycmd:command.get_short_description() {
    local short_description

    if short_description="$(mycmd:command._get_optional_field_from_command_struct \
        "${_COMMAND_SHORT_DESC_FIELD}" \
        "${@}")"; then
        readonly short_description
    else
        local namespaced_parts
        namespaced_parts="$(mycmd:command.get_namespaced_parts_as_string "${@}")"
        readonly namespaced_parts
        short_description="MyCmd Command ${namespaced_parts}"
        readonly short_description
    fi

    echo "${short_description}"
    return 0
}

function mycmd:command.get_long_description() {
    mycmd:command._get_optional_field_from_command_struct \
        "${_COMMAND_LONG_DESC_FIELD}" \
        "${@}"
}

function mycmd:command.get_version() {
    local version

    if version="$(mycmd:command._get_optional_field_from_command_struct \
        "${_COMMAND_VERSION_FIELD}" \
        "${@}")"; then
        echo "${version}"
        return 0
    else
        echo "Unknown"
        return 0
    fi
}

function mycmd:command.is_source_loaded() {
    local -n command_struct_ref="${1}"
    local source_file
    if ! source_file="$(mycmd:command.get_source_file "${@}")"; then
        return 1
    fi
    readonly source_file

    mycmd._file_has_been_loaded "${source_file}"
}

mycmd.trace "The MyCmd Command support library has been sourced."

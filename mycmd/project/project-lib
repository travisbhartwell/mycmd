# -*- mode: shell-script; sh-shell: bash; sh-basic-offset: 4; sh-indentation: 4; coding: utf-8 -*-
# shellcheck shell=bash

# MyCmd Project Command Group Library
#   Library for Project Task Runner Functionality

# Set Bash options for safety
set -o nounset -o errexit -o errtrace -o pipefail

# This file should only be sourced and not executed directly, so exit with error
# with execution is attempted. Technique borrowed from
# https://stackoverflow.com/a/28776166
(return 0 >/dev/null 2>&1) || {
    echo >&2 "$0 is a library only meant to be sourced."
    exit 1
}

mycmd.register_command_group_version "0.1"
mycmd.register_command_group_short_desc "MyCmd Project Command Group Library"
mycmd.register_command_group_long_desc "Library for Project Task Runner Functionality"

[[ -n "${_MYCMD_SOURCING_COMMAND_GROUP_FOR_HELP:-}" ]] && return

# This library should only be sourced once. Technique borrowed from
# https://stackoverflow.com/a/64534652
[[ -n "${_MYCMD_PROJECT_LIB:-}" ]] && return
readonly _MYCMD_PROJECT_LIB=1

declare -Agx _MYCMD_PROJECT_FILESETS=()
declare -Agx _MYCMD_PROJECT_TASKS=()
declare -Agx _MYCMD_PROJECT_TASK_FILESET=()

# project.find_up
# - returns 1 if the file is not found in the current directory or any parent
# - returns 0 if the file is found in the current directory or any parent
# if found, the absolute path of the location of the file is echoed
function project.find_up() {
    local -r name_to_find="${1}"
    local starting_dir="${2}"

    if ! starting_dir="$(mycmd.canonicalize_path "${starting_dir}")"; then
        mycmd.debug "'${starting_dir}' not found."
        return 1
    fi

    local -r possible_path="${starting_dir}/${name_to_find}"

    if [[ -e "${possible_path}" ]]; then
        echo "${possible_path}"
        return 0
    fi

    if [[ "${starting_dir}" = "/" ]]; then
        mycmd.debug "File '${name_to_find}' not found"
        return 1
    fi

    project.find_up "${name_to_find}" "${starting_dir}/.."
}

function project.find_closest_project_file() {
    local -r starting_dir="${1}"

    project.find_up myproject "${starting_dir}"
}

function project.load_project_file() {
    declare -rgx MYPROJECT_PROJECT_FILE="${1}"
    shift

    declare -gx MYPROJECT_BASE_DIR
    if ! MYPROJECT_BASE_DIR="$(cd "$(dirname "${MYPROJECT_PROJECT_FILE}")" &>/dev/null && pwd -P)"; then
        mycmd.log "Error fetching project directory."
        return 1
    fi
    readonly MYPROJECT_BASE_DIR

    if ! mycmd.source_lib_by_path_if_found "${MYPROJECT_PROJECT_FILE}"; then
        mycmd.log "Error loading project file '${MYPROJECT_PROJECT_FILE}'"
        return 1
    fi
}

function project.load_closest_project_file() {
    local project_file_path
    if ! project_file_path="$(project.find_closest_project_file "${PWD}")"; then
        mycmd.log "No project file (named myproject) found in this directory or any parent."
        return 1
    fi
    readonly project_file_path

    if ! project.load_project_file "${project_file_path}"; then
        mycmd.log "Error loading project file."
        return 1
    fi

    return 0
}

function project.register_task() {
    local -r task_name="${1}"
    if (($# > 1)); then
        local -r task_function_name="${2}"
    else
        local -r task_function_name="${1}"
    fi

    if [[ -v _MYCMD_PROJECT_TASKS[${task_name}] ]]; then
        mycmd.log "Task '${task_name}' already registered."
        return 1
    fi

    _MYCMD_PROJECT_TASKS[${task_name}]="${task_function_name}"
    mycmd.trace "Registered task '${task_name}' with function '${task_function_name}'."
}

function project.register_task_with_fileset() {
    local -r task_name="${1}"
    local -r task_function_name="${2}"
    local -r fileset_name="${3}"

    if [[ -v _MYCMD_PROJECT_TASKS[${task_name}] ]]; then
        mycmd.log "Task '${task_name}' already registered."
        return 1
    fi

    _MYCMD_PROJECT_TASKS[${task_name}]="${task_function_name}"
    _MYCMD_PROJECT_TASK_FILESET[${task_name}]="${fileset_name}"
    mycmd.trace "Registered task '${task_name}' with function '${task_function_name}' and the fileset '${fileset_name}'."
}

function project.execute_task() {
    local -r task_name="${1}"
    shift

    local fn=${_MYCMD_PROJECT_TASKS[${task_name}]}

    cd "${MYPROJECT_BASE_DIR}"

    local return_code=0

    if [[ ! -v _MYCMD_PROJECT_TASKS[${task_name}] ]]; then
        mycmd.log "Unknown task: '${task_name}'."
        return_code=1
    elif ! mycmd.function_exists "${fn}"; then
        mycmd.log "Unknown task function: '${fn}' for task '${task_name}'."
        return_code=1
    else
        mycmd.output "➡️ Executing task '${task_name}'..."

        if [[ -v _MYCMD_PROJECT_TASK_FILESET[${task_name}] ]]; then
            local fileset_name="${_MYCMD_PROJECT_TASK_FILESET[${task_name}]}"

            if [[ ! -v _MYCMD_PROJECT_FILESETS[${fileset_name}] ]]; then
                mycmd.log "Specified file set '${fileset_name}' for task '${task_name}' not defined."
                return_code=1
            else
                "${fn}" "${fileset_name}" "${@}" || return_code=$?
            fi
        else
            "${fn}" "${@}" || return_code=$?
        fi
    fi

    if ((return_code == 0)); then
        mycmd.output "✅ Task '${fn}' succeeded."
    else
        mycmd.output "❌ Task '${fn}' failed."
    fi

    return "${return_code}"
}

function project.list_registered_tasks() {
    if (("${#_MYCMD_PROJECT_TASKS[@]}" == 0)); then
        mycmd.output "There are no registered tasks."
        return 0
    fi

    local -a sorted_task_names
    # shellcheck disable=SC2034
    readarray -t sorted_task_names < \
        <(printf '%s\n' "${!_MYCMD_PROJECT_TASKS[@]}" | LC_ALL=en_US.UTF-8 sort || true)

    mycmd.output "The following tasks are registered:"

    local task
    for task in "${sorted_task_names[@]}"; do
        mycmd.output "${task}"
    done
}

function project.register_fileset() {
    local -r fileset_name="${1}"
    declare -agx "${fileset_name}=()"
    _MYCMD_PROJECT_FILESETS[${fileset_name}]=1
}

mycmd.defer_at_startup mycmd.init_bin find
mycmd.defer_at_startup mycmd.init_bin realpath
function project.find_files_for_fileset() {
    local -n fileset="${1}"
    shift

    if ! [[ "${*}" =~ .*-print0.* ]]; then
        set -- "${@}" -print0
    fi

    local realpath_exe
    if ! realpath_exe="$(mycmd._locate_bin realpath)"; then
        mycmd.debug "Unable to find realpath"
        return 1
    fi
    readonly realpath_exe

    # shellcheck disable=SC2034
    readarray -t fileset < <(mycmd.bin_execute find "${@}" \
        | xargs -0 "${realpath_exe}" --relative-to="${MYPROJECT_BASE_DIR}" \
        | LC_ALL=en_US.UTF-8 sort || true)
}

mycmd.defer_at_startup mycmd.init_bin realpath
function project.add_files_to_fileset() {
    local -n fileset_to_append="${1}"
    shift

    local filename
    local relative_filename

    for filename in "${@}"; do
        if ! relative_filename="$(mycmd.bin_execute realpath --relative-to="${MYPROJECT_BASE_DIR}" "${filename}")"; then
            mycmd.debug "Error getting relative path for ${filename}"
            return 1
        fi

        fileset_to_append+=("${relative_filename}")
    done
}

function project.list-files() {
    local -n fileset_to_list="${1}"

    echo "${fileset_to_list[*]}" | tr ' ' '\n'
}

function project.verbose_enabled() {
    [[ -n "${MYPROJECT_VERBOSE-}" ]]
}

function project.verbose() {
    if project.verbose_enabled; then
        mycmd.output "[VERBOSE] ${*}"
    fi
}

function project.load_task_library() {
    local -r task_library="${1}"
    local -r full_library_name="project/${task_library}"

    mycmd.source_mycmd_lib "${full_library_name}"
}

mycmd.trace "The MyCmd Project command group library has been sourced."

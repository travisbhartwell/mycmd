# -*- mode: shell-script; sh-shell: bash; sh-basic-offset: 4; sh-indentation: 4; coding: utf-8 -*-
# shellcheck shell=bash

# MyCmd Project Command Group Library
#   Library for Project Task Runner Functionality

# Set Bash options for safety
set -o nounset -o errexit -o errtrace -o pipefail

# This file should only be sourced and not executed directly, so exit with error
# with execution is attempted. Technique borrowed from
# https://stackoverflow.com/a/28776166
(return 0 >/dev/null 2>&1) || {
    echo >&2 "$0 is a library only meant to be sourced."
    exit 1
}

mycmd.register_command_group_version "0.1"
mycmd.register_command_group_short_desc "MyCmd Project Command Group Library"
mycmd.register_command_group_long_desc "Library for Project Task Runner Functionality"

[[ -n "${_MYCMD_SOURCING_COMMAND_GROUP_FOR_HELP:-}" ]] && return

# This library should only be sourced once. Technique borrowed from
# https://stackoverflow.com/a/64534652
[[ -n "${_MYCMD_PROJECT_LIB:-}" ]] && return
readonly _MYCMD_PROJECT_LIB=1

declare -Agx _MYCMD_PROJECT_FILESETS=()
declare -Agx _MYCMD_PROJECT_TASKS=()
declare -Agx _MYCMD_PROJECT_TASK_FILESETS=()
declare -Agx _MYCMD_PROJECT_TASK_ARGUMENTS_REF_NAMES=()
declare -Agx _MYCMD_PROJECT_TASK_ARGUMENT_INDICES=()
declare -Agx _MYCMD_PROJECT_TASK_ARGUMENT_COUNTS=()
declare -agx _MYCMD_PROJECT_TASK_ARGUMENTS=()
declare -gx _MYCMD_PROJECT_DEFAULT_TASK

readonly _MYCMD_PROJECT_TASK_NAME_FIELD='project-task-name'
readonly _MYCMD_PROJECT_TASK_FUNCTION_FIELD='project-task-fn'
readonly _MYCMD_PROJECT_TASK_FILESET_FIELD='project-task-fileset'
readonly _MYCMD_PROJECT_TASK_ARGUMENT_REF_NAME_FIELD='project-task-arg-ref-name'
readonly _MYCMD_PROJECT_TASK_ARGUMENT_INDEX_FIELD='project-task-arg-index'
readonly _MYCMD_PROJECT_TASK_ARGUMENT_COUNT_FIELD='project-task-argc'

function project.task._new_task() {
    local -n new_task_tasks_ref="${1}"
    local -r arguments_ref_name="${2}"
    local -n new_task_task_arguments_ref="${arguments_ref_name}"
    local -n new_task_task_argument_ref_names="${3}"
    local -n new_task_task_arg_indices_ref="${4}"
    local -n new_task_task_arg_counts_ref="${5}"
    shift 5

    local -r task_name="${1}"
    local -r task_function_name="${2}"
    shift 2

    if [[ -v new_task_tasks_ref[${task_name}] ]]; then
        mycmd.log "Task '${task_name}' already registered."
        return 1
    fi

    new_task_tasks_ref["${task_name}"]="${task_function_name}"
    mycmd.trace "Created task '${task_name}' with function '${task_function_name}'."

    local argc=$#
    new_task_task_arg_counts_ref["${task_name}"]="${argc}"

    if ((argc > 0)); then
        local index="${#new_task_task_arguments_ref[@]}"
        new_task_task_arguments_ref+=("${@}")
        new_task_task_argument_ref_names["${task_name}"]="${arguments_ref_name}"
        new_task_task_arg_indices_ref["${task_name}"]="${index}"

        mycmd.trace "Registered ${argc} arguments for task '${task_name}' at index ${index}."
    else
        mycmd.trace "Registered 0 arguments for task '${task_name}'."
    fi

}

function project.task._new_task_with_fileset() {
    local -r new_task_fileset_tasks_ref_name="${1}"
    local -n new_task_fileset_task_filesets_ref="${2}"
    local -r new_task_fileset_task_arguments_ref_name="${3}"
    local -r new_task_fileset_task_argument_ref_names_name="${4}"
    local -r new_task_fileset_task_arg_indices_ref_name="${5}"
    local -r new_task_fileset_task_arg_counts_ref_name="${6}"
    shift 6

    local -r task_name="${1}"
    local -r task_function_name="${2}"
    local -r task_fileset_name="${3}"
    shift 3

    if ! project.task._new_task \
        "${new_task_fileset_tasks_ref_name}" \
        "${new_task_fileset_task_arguments_ref_name}" \
        "${new_task_fileset_task_argument_ref_names_name}" \
        "${new_task_fileset_task_arg_indices_ref_name}" \
        "${new_task_fileset_task_arg_counts_ref_name}" \
        "${task_name}" \
        "${task_function_name}" \
        "${@}"; then
        return 1
    fi

    new_task_fileset_task_filesets_ref["${task_name}"]="${task_fileset_name}"
    mycmd.trace "Registered fileset '${task_fileset_name}' for task '${task_name}'."
}

function project.task.get_task() {
    project.task._get_task \
        _MYCMD_PROJECT_TASKS \
        _MYCMD_PROJECT_TASK_FILESETS \
        _MYCMD_PROJECT_TASK_ARGUMENTS_REF_NAMES \
        _MYCMD_PROJECT_TASK_ARGUMENT_INDICES \
        _MYCMD_PROJECT_TASK_ARGUMENT_COUNTS \
        "${@}"
}

function project.task._get_task() {
    local -n get_task_tasks_ref="${1}"
    local -n get_task_task_filesets_ref="${2}"
    local -n get_task_task_arguments_ref_names_ref="${3}"
    local -n get_task_task_arg_indices_ref="${4}"
    local -n get_task_task_arg_counts_ref="${5}"
    shift 5

    local -r task_name="${1}"
    local -n get_task_struct_ref="${2}"

    if [[ ! -v get_task_tasks_ref[${task_name}] ]]; then
        mycmd.log "Unknown task: '${task_name}'."
        return 1
    fi

    mycmd.trace "Returning task definition:"
    get_task_struct_ref["${_MYCMD_PROJECT_TASK_NAME_FIELD}"]="${task_name}"
    mycmd.trace "- ${_MYCMD_PROJECT_TASK_NAME_FIELD}: ${get_task_struct_ref["${_MYCMD_PROJECT_TASK_NAME_FIELD}"]}"

    get_task_struct_ref["${_MYCMD_PROJECT_TASK_FUNCTION_FIELD}"]="${get_task_tasks_ref["${task_name}"]}"
    mycmd.trace "- ${_MYCMD_PROJECT_TASK_FUNCTION_FIELD}: ${get_task_struct_ref["${_MYCMD_PROJECT_TASK_FUNCTION_FIELD}"]}"

    local count="${get_task_task_arg_counts_ref["${task_name}"]}"
    get_task_struct_ref["${_MYCMD_PROJECT_TASK_ARGUMENT_COUNT_FIELD}"]="${count}"
    mycmd.trace "- ${_MYCMD_PROJECT_TASK_ARGUMENT_COUNT_FIELD}: ${get_task_struct_ref["${_MYCMD_PROJECT_TASK_ARGUMENT_COUNT_FIELD}"]}"

    if ((count > 0)); then
        get_task_struct_ref["${_MYCMD_PROJECT_TASK_ARGUMENT_INDEX_FIELD}"]="${get_task_task_arg_indices_ref["${task_name}"]}"
        mycmd.trace "- ${_MYCMD_PROJECT_TASK_ARGUMENT_INDEX_FIELD}: ${get_task_struct_ref["${_MYCMD_PROJECT_TASK_ARGUMENT_INDEX_FIELD}"]}"

        get_task_struct_ref["${_MYCMD_PROJECT_TASK_ARGUMENT_REF_NAME_FIELD}"]="${get_task_task_arguments_ref_names_ref["${task_name}"]}"
        mycmd.trace "- ${_MYCMD_PROJECT_TASK_ARGUMENT_REF_NAME_FIELD}: ${get_task_struct_ref["${_MYCMD_PROJECT_TASK_ARGUMENT_REF_NAME_FIELD}"]}"
    else
        mycmd.trace "- ${_MYCMD_PROJECT_TASK_ARGUMENT_INDEX_FIELD}: No index set"
    fi

    if [[ -v get_task_task_filesets_ref[${task_name}] ]]; then
        get_task_struct_ref["${_MYCMD_PROJECT_TASK_FILESET_FIELD}"]="${get_task_task_filesets_ref["${task_name}"]}"
        mycmd.trace "- ${_MYCMD_PROJECT_TASK_FILESET_FIELD}: ${get_task_struct_ref["${_MYCMD_PROJECT_TASK_FILESET_FIELD}"]}"
    else
        mycmd.trace "- ${_MYCMD_PROJECT_TASK_FILESET_FIELD}: No fileset set"
    fi
}

function project.task.get_name() {
    local -n get_name_struct_ref="${1}"
    shift

    echo "${get_name_struct_ref["${_MYCMD_PROJECT_TASK_NAME_FIELD}"]}"
}

function project.task.get_function_name() {
    local -n get_function_name_struct_ref="${1}"
    shift

    echo "${get_function_name_struct_ref["${_MYCMD_PROJECT_TASK_FUNCTION_FIELD}"]}"
}

function project.task.get_argument_count() {
    local -n get_argument_count_struct_ref="${1}"
    shift

    echo "${get_argument_count_struct_ref["${_MYCMD_PROJECT_TASK_ARGUMENT_COUNT_FIELD}"]}"
}

function project.task.get_argument_index() {
    local -n get_argument_index_struct_ref="${1}"
    shift

    if [[ -v get_argument_index_struct_ref["${_MYCMD_PROJECT_TASK_ARGUMENT_INDEX_FIELD}"] ]]; then
        echo "${get_argument_index_struct_ref["${_MYCMD_PROJECT_TASK_ARGUMENT_INDEX_FIELD}"]}"
        return 0
    else
        mycmd.trace "No argument index defined for ${get_argument_index_struct_ref["${_MYCMD_PROJECT_TASK_NAME_FIELD}"]}"
        return 1
    fi
}

function project.task.get_arguments_ref_name() {
    local -n get_arguments_ref_name_struct_ref="${1}"
    shift

    if [[ -v get_arguments_ref_name_struct_ref["${_MYCMD_PROJECT_TASK_ARGUMENT_REF_NAME_FIELD}"] ]]; then
        echo "${get_arguments_ref_name_struct_ref["${_MYCMD_PROJECT_TASK_ARGUMENT_REF_NAME_FIELD}"]}"
        return 0
    else
        mycmd.trace "No arguments ref name defined for ${get_arguments_ref_name_struct_ref["${_MYCMD_PROJECT_TASK_NAME_FIELD}"]}"
        return 1
    fi
}

function project.task.get_fileset() {
    local -n get_fileset_struct_ref="${1}"
    shift

    if [[ -v get_fileset_struct_ref["${_MYCMD_PROJECT_TASK_FILESET_FIELD}"] ]]; then
        echo "${get_fileset_struct_ref["${_MYCMD_PROJECT_TASK_FILESET_FIELD}"]}"
        return 0
    else
        mycmd.trace "No fileset defined for ${get_fileset_struct_ref["${_MYCMD_PROJECT_TASK_NAME_FIELD}"]}"
        return 1
    fi
}

function project.task.get_arguments() {
    local -n get_arguments_struct_ref="${1}"
    local -n get_arguments_arguments_ref="${2}"
    shift 2

    local -r task_name="${get_arguments_struct_ref["${_MYCMD_PROJECT_TASK_NAME_FIELD}"]}"

    local -i argc
    argc="${get_arguments_struct_ref["${_MYCMD_PROJECT_TASK_ARGUMENT_COUNT_FIELD}"]}"
    readonly argc

    if ((argc == 0)); then
        mycmd.trace "No arguments defined for task '${task_name}'."
        return 0
    fi

    local -i index
    index="${get_arguments_struct_ref["${_MYCMD_PROJECT_TASK_ARGUMENT_INDEX_FIELD}"]}"
    readonly index

    local -n arguments_ref="${get_arguments_struct_ref["${_MYCMD_PROJECT_TASK_ARGUMENT_REF_NAME_FIELD}"]}"

    get_arguments_arguments_ref=("${arguments_ref[@]:index:argc}")
}

function project.enable_quiet_mode() {
    declare -gx MYPROJECT_QUIET=1
}

function project.disable_quiet_mode() {
    if [[ -v MYPROJECT_QUIET ]]; then
        unset -v MYPROJECT_QUIET
    fi
}

function project.is_quiet_enabled() {
    [[ -n "${MYPROJECT_QUIET-}" ]]
}

function project.output_only_if_not_quiet() {
    project.is_quiet_enabled \
        || mycmd.output "${*}"
}

function project.enable_verbose_mode() {
    declare -gx MYPROJECT_VERBOSE=1
}

function project.disable_verbose_mode() {
    if [[ -v MYPROJECT_VERBOSE ]]; then
        unset -v MYPROJECT_VERBOSE
    fi
}

function project.is_verbose_enabled() {
    [[ -n "${MYPROJECT_VERBOSE-}" ]]
}

function project.verbose() {
    if project.is_verbose_enabled; then
        mycmd.output "[VERBOSE] ${*}"
    fi
}

function project.get_default_task() {
    if [[ -v _MYCMD_PROJECT_DEFAULT_TASK ]]; then
        echo "${_MYCMD_PROJECT_DEFAULT_TASK}"
        return 0
    else
        return 1
    fi
}

# project.find_up
# - returns 1 if the file is not found in the current directory or any parent
# - returns 0 if the file is found in the current directory or any parent
# if found, the absolute path of the location of the file is echoed
function project.find_up() {
    local -r name_to_find="${1}"
    local starting_dir="${2}"

    if ! starting_dir="$(mycmd.canonicalize_path "${starting_dir}")"; then
        mycmd.debug "'${starting_dir}' not found."
        return 1
    fi

    local -r possible_path="${starting_dir}/${name_to_find}"

    if [[ -e "${possible_path}" ]]; then
        echo "${possible_path}"
        return 0
    fi

    if [[ "${starting_dir}" = "/" ]]; then
        mycmd.debug "File '${name_to_find}' not found"
        return 1
    fi

    project.find_up "${name_to_find}" "${starting_dir}/.."
}

function project.find_closest_project_file() {
    local -r starting_dir="${1}"

    project.find_up myproject "${starting_dir}"
}

function project.load_project_file() {
    declare -rgx MYPROJECT_PROJECT_FILE="${1}"
    shift

    declare -gx MYPROJECT_BASE_DIR
    if ! MYPROJECT_BASE_DIR="$(cd "$(dirname "${MYPROJECT_PROJECT_FILE}")" &>/dev/null && pwd -P)"; then
        mycmd.log "Error fetching project directory."
        return 1
    fi
    readonly MYPROJECT_BASE_DIR

    if ! mycmd.source_lib_by_path_if_found "${MYPROJECT_PROJECT_FILE}"; then
        mycmd.log "Error loading project file '${MYPROJECT_PROJECT_FILE}'"
        return 1
    fi
}

function project.load_closest_project_file() {
    local project_file_path
    if ! project_file_path="$(project.find_closest_project_file "${PWD}")"; then
        mycmd.log "No project file (named 'myproject') found in this directory or any parent."
        return 1
    fi
    readonly project_file_path

    if ! project.load_project_file "${project_file_path}"; then
        mycmd.log "Error loading project file."
        return 1
    fi

    return 0
}

function project.register_task() {
    if (($# == 1)); then
        set -- "${1}" "${1}"
    fi

    project.task._new_task \
        _MYCMD_PROJECT_TASKS \
        _MYCMD_PROJECT_TASK_ARGUMENTS \
        _MYCMD_PROJECT_TASK_ARGUMENTS_REF_NAMES \
        _MYCMD_PROJECT_TASK_ARGUMENT_INDICES \
        _MYCMD_PROJECT_TASK_ARGUMENT_COUNTS \
        "${@}"
}

function project.register_task_with_fileset() {
    project.task._new_task_with_fileset \
        _MYCMD_PROJECT_TASKS \
        _MYCMD_PROJECT_TASK_FILESETS \
        _MYCMD_PROJECT_TASK_ARGUMENTS \
        _MYCMD_PROJECT_TASK_ARGUMENTS_REF_NAMES \
        _MYCMD_PROJECT_TASK_ARGUMENT_INDICES \
        _MYCMD_PROJECT_TASK_ARGUMENT_COUNTS \
        "${@}"
}

function project.function_exists_for_task() {
    local -r task_name="${1}"
    local -r fn="${_MYCMD_PROJECT_TASKS[${task_name}]}"

    if ! mycmd.function_exists "${fn}"; then
        mycmd.log "Unknown task function: '${fn}' for task '${task_name}'."
        return 1
    fi

    return 0
}

function project.register_default_task() {
    local -r task_name="${1}"

    if [[ -v _MYCMD_PROJECT_TASKS[${task_name}] ]]; then
        _MYCMD_PROJECT_DEFAULT_TASK="${task_name}"
        return 0
    else
        mycmd.log "Unknown task '${task_name}' specified as default task."
        return 1
    fi
}

function project.execute_task() {
    local -r task_name="${1}"
    shift

    local return_code=0

    if [[ ! -v _MYCMD_PROJECT_TASKS[${task_name}] ]]; then
        mycmd.log "Unknown task: '${task_name}'."
        return_code=1
    elif ! project.function_exists_for_task "${task_name}"; then
        return_code=1
    else
        local fn=${_MYCMD_PROJECT_TASKS[${task_name}]}
        mycmd.debug "Executing function '${fn}' for task '${task_name}'."

        mycmd.output "➡️ Executing task '${task_name}'..."

        cd "${MYPROJECT_BASE_DIR}"

        if [[ -v _MYCMD_PROJECT_TASK_FILESETS[${task_name}] ]]; then
            local fileset_name="${_MYCMD_PROJECT_TASK_FILESETS[${task_name}]}"

            if [[ ! -v _MYCMD_PROJECT_FILESETS[${fileset_name}] ]]; then
                mycmd.log "Specified file set '${fileset_name}' for task '${task_name}' not defined."
                return_code=1
            else
                "${fn}" "${fileset_name}" "${@}" || return_code=$?
            fi
        else
            "${fn}" "${@}" || return_code=$?
        fi
    fi

    if ((return_code == 0)); then
        mycmd.output "✅ Task '${task_name}' succeeded."
    else
        mycmd.output "❌ Task '${task_name}' failed."
    fi

    return "${return_code}"
}

function project.execute_tasks() {
    for task in "${@}"; do
        local return_code=0

        project.execute_task "${task}" || return_code=$?

        if ((return_code != 0)); then
            return "${return_code}"
        fi
    done
}

function project.list_registered_tasks() {
    if (("${#_MYCMD_PROJECT_TASKS[@]}" == 0)); then
        project.output_only_if_not_quiet "There are no registered tasks."
        return 0
    fi

    local -a sorted_task_names
    # shellcheck disable=SC2034
    readarray -t sorted_task_names < \
        <(printf '%s\n' "${!_MYCMD_PROJECT_TASKS[@]}" | LC_ALL=en_US.UTF-8 sort || true)

    project.output_only_if_not_quiet "The following tasks are registered:"

    local task
    for task in "${sorted_task_names[@]}"; do
        mycmd.output "${task}"
    done
}

function project.register_fileset() {
    local -r fileset_name="${1}"
    declare -agx "${fileset_name}=()"
    _MYCMD_PROJECT_FILESETS[${fileset_name}]=1
}

mycmd.defer_at_startup mycmd.init_bin find
mycmd.defer_at_startup mycmd.init_bin realpath
function project.find_files_for_fileset() {
    local -n fileset="${1}"
    shift

    if ! [[ "${*}" =~ .*-print0.* ]]; then
        set -- "${@}" -print0
    fi

    local realpath_exe
    if ! realpath_exe="$(mycmd._locate_bin realpath)"; then
        mycmd.debug "Unable to find realpath"
        return 1
    fi
    readonly realpath_exe

    # shellcheck disable=SC2034
    readarray -t fileset < <(mycmd.bin_execute find "${@}" \
        | xargs -0 "${realpath_exe}" --relative-to="${MYPROJECT_BASE_DIR}" \
        | LC_ALL=en_US.UTF-8 sort || true)
}

mycmd.defer_at_startup mycmd.init_bin realpath
function project.add_files_to_fileset() {
    local -n fileset_to_append="${1}"
    shift

    local filename
    local relative_filename

    for filename in "${@}"; do
        if ! relative_filename="$(mycmd.bin_execute realpath --relative-to="${MYPROJECT_BASE_DIR}" "${filename}")"; then
            mycmd.debug "Error getting relative path for ${filename}"
            return 1
        fi

        fileset_to_append+=("${relative_filename}")
    done
}

function project.list-files() {
    local -n fileset_to_list="${1}"

    echo "${fileset_to_list[*]}" | tr ' ' '\n'
}

function project.load_task_library() {
    local -r task_library="${1}"
    local -r full_library_name="project/${task_library}"

    mycmd.source_mycmd_lib "${full_library_name}"
}

mycmd.trace "The MyCmd Project command group library has been sourced."

# -*- mode: shell-script; sh-shell: bash; sh-basic-offset: 4; sh-indentation: 4; coding: utf-8 -*-
# shellcheck shell=bash

# MyCmd Project Commad Group Library Task Support Library
#   Support for Task Definition Data Structures and Related Functions for Project Runner

# Set Bash options for safety
set -o nounset -o errexit -o errtrace -o pipefail

# This file should only be sourced and not executed directly, so exit with error
# with execution is attempted. Technique borrowed from
# https://stackoverflow.com/a/28776166
(return 0 >/dev/null 2>&1) || {
    echo >&2 "$0 is a library only meant to be sourced."
    exit 1
}

# This library should only be sourced once. Technique borrowed from
# https://stackoverflow.com/a/64534652
[[ -n "${_MYCMD_PROJECT_TASK_LIB:-}" ]] && return
readonly _MYCMD_PROJECT_TASK_LIB=1

readonly _TASK_NAME_FIELD='project-task-name'
readonly _TASK_FUNCTION_FIELD='project-task-fn'
readonly _TASK_FILESET_FIELD='project-task-fileset'
readonly _TASK_ARGUMENTS_REF_NAME_FIELD='project-task-args-ref-name'
readonly _TASK_ARGUMENT_INDEX_FIELD='project-task-arg-index'
readonly _TASK_ARGUMENT_COUNT_FIELD='project-task-argc'

function project:task._new_task() {
    local -n new_task_tasks_ref="${1}"
    local -r arguments_ref_name="${2}"
    local -n new_task_task_arguments_ref="${arguments_ref_name}"
    local -n new_task_task_argument_ref_names="${3}"
    local -n new_task_task_arg_indices_ref="${4}"
    local -n new_task_task_arg_counts_ref="${5}"
    shift 5

    local -r task_name="${1}"
    local -r task_function_name="${2}"
    shift 2

    if [[ -v new_task_tasks_ref[${task_name}] ]]; then
        mycmd.log "Task '${task_name}' already registered."
        return 1
    fi

    new_task_tasks_ref["${task_name}"]="${task_function_name}"
    mycmd.trace "Created task '${task_name}' with function '${task_function_name}'."

    local argc=$#
    new_task_task_arg_counts_ref["${task_name}"]="${argc}"

    if ((argc > 0)); then
        local index="${#new_task_task_arguments_ref[@]}"
        new_task_task_arguments_ref+=("${@}")
        new_task_task_argument_ref_names["${task_name}"]="${arguments_ref_name}"
        new_task_task_arg_indices_ref["${task_name}"]="${index}"

        mycmd.trace "Registered ${argc} arguments for task '${task_name}' at index ${index}."
    else
        mycmd.trace "Registered 0 arguments for task '${task_name}'."
    fi
}

function project:task._new_task_with_fileset() {
    local -r new_task_fileset_tasks_ref_name="${1}"
    local -n new_task_fileset_task_filesets_ref="${2}"
    local -r new_task_fileset_task_arguments_ref_name="${3}"
    local -r new_task_fileset_task_argument_ref_names_name="${4}"
    local -r new_task_fileset_task_arg_indices_ref_name="${5}"
    local -r new_task_fileset_task_arg_counts_ref_name="${6}"
    shift 6

    local -r task_name="${1}"
    local -r task_function_name="${2}"
    local -r task_fileset_name="${3}"
    shift 3

    if ! project:task._new_task \
        "${new_task_fileset_tasks_ref_name}" \
        "${new_task_fileset_task_arguments_ref_name}" \
        "${new_task_fileset_task_argument_ref_names_name}" \
        "${new_task_fileset_task_arg_indices_ref_name}" \
        "${new_task_fileset_task_arg_counts_ref_name}" \
        "${task_name}" \
        "${task_function_name}" \
        "${@}"; then
        return 1
    fi

    new_task_fileset_task_filesets_ref["${task_name}"]="${task_fileset_name}"

    mycmd.trace "Registered fileset '${task_fileset_name}' for task '${task_name}' in ${!new_task_fileset_task_filesets_ref}."
}

function project:task._get_task() {
    local -n get_task_tasks_ref="${1}"
    local -n get_task_task_filesets_ref="${2}"
    local -n get_task_task_arguments_ref_names_ref="${3}"
    local -n get_task_task_arg_indices_ref="${4}"
    local -n get_task_task_arg_counts_ref="${5}"
    shift 5

    local -r task_name="${1}"
    local -n get_task_struct_ref="${2}"

    if [[ ! -v get_task_tasks_ref[${task_name}] ]]; then
        mycmd.log "Unknown task: '${task_name}'."
        return 1
    fi

    mycmd.trace "Returning task definition:"
    get_task_struct_ref["${_TASK_NAME_FIELD}"]="${task_name}"
    mycmd.trace "- ${_TASK_NAME_FIELD}: ${get_task_struct_ref["${_TASK_NAME_FIELD}"]}"

    get_task_struct_ref["${_TASK_FUNCTION_FIELD}"]="${get_task_tasks_ref["${task_name}"]}"
    mycmd.trace "- ${_TASK_FUNCTION_FIELD}: ${get_task_struct_ref["${_TASK_FUNCTION_FIELD}"]}"

    local count="${get_task_task_arg_counts_ref["${task_name}"]}"
    get_task_struct_ref["${_TASK_ARGUMENT_COUNT_FIELD}"]="${count}"
    mycmd.trace "- ${_TASK_ARGUMENT_COUNT_FIELD}: ${get_task_struct_ref["${_TASK_ARGUMENT_COUNT_FIELD}"]}"

    if ((count > 0)); then
        get_task_struct_ref["${_TASK_ARGUMENT_INDEX_FIELD}"]="${get_task_task_arg_indices_ref["${task_name}"]}"
        mycmd.trace "- ${_TASK_ARGUMENT_INDEX_FIELD}: ${get_task_struct_ref["${_TASK_ARGUMENT_INDEX_FIELD}"]}"

        get_task_struct_ref["${_TASK_ARGUMENTS_REF_NAME_FIELD}"]="${get_task_task_arguments_ref_names_ref["${task_name}"]}"
        mycmd.trace "- ${_TASK_ARGUMENTS_REF_NAME_FIELD}: ${get_task_struct_ref["${_TASK_ARGUMENTS_REF_NAME_FIELD}"]}"
    else
        mycmd.trace "- ${_TASK_ARGUMENT_INDEX_FIELD}: No index set"
        mycmd.trace "- ${_TASK_ARGUMENTS_REF_NAME_FIELD}: No task arguments ref names ref set"
    fi

    if [[ -v get_task_task_filesets_ref[${task_name}] ]]; then
        get_task_struct_ref["${_TASK_FILESET_FIELD}"]="${get_task_task_filesets_ref["${task_name}"]}"
        mycmd.trace "- ${_TASK_FILESET_FIELD}: ${get_task_struct_ref["${_TASK_FILESET_FIELD}"]}"
    else
        mycmd.trace "- ${_TASK_FILESET_FIELD}: No fileset set"
    fi
}

function project:task.get_name() {
    local -n get_name_struct_ref="${1}"
    shift

    mycmd.trace "${get_name_struct_ref[*]}"
    echo "${get_name_struct_ref["${_TASK_NAME_FIELD}"]}"
}

function project:task.get_function_name() {
    local -n get_function_name_struct_ref="${1}"
    shift

    echo "${get_function_name_struct_ref["${_TASK_FUNCTION_FIELD}"]}"
}

function project:task.function_exists_for_task() {
    local -n task="${1}"

    local fn
    fn=$(project:task.get_function_name task)
    readonly fn

    if ! mycmd.function_exists "${fn}"; then
        local task_name
        task_name=$(project:task.get_name task)
        mycmd.log "Unknown task function: '${fn}' for task '${task_name}'."
        return 1
    fi

    return 0
}

function project:task.get_argument_count() {
    local -n get_argument_count_struct_ref="${1}"
    shift

    echo "${get_argument_count_struct_ref["${_TASK_ARGUMENT_COUNT_FIELD}"]}"
}

function project:task.get_argument_index() {
    local -n get_argument_index_struct_ref="${1}"
    shift

    if [[ -v get_argument_index_struct_ref["${_TASK_ARGUMENT_INDEX_FIELD}"] ]]; then
        echo "${get_argument_index_struct_ref["${_TASK_ARGUMENT_INDEX_FIELD}"]}"
        return 0
    else
        mycmd.trace "No argument index defined for ${get_argument_index_struct_ref["${_TASK_NAME_FIELD}"]}"
        return 1
    fi
}

function project:task.get_arguments_ref_name() {
    local -n get_arguments_ref_name_struct_ref="${1}"
    shift

    if [[ -v get_arguments_ref_name_struct_ref["${_TASK_ARGUMENTS_REF_NAME_FIELD}"] ]]; then
        echo "${get_arguments_ref_name_struct_ref["${_TASK_ARGUMENTS_REF_NAME_FIELD}"]}"
        return 0
    else
        mycmd.trace "No arguments ref name defined for ${get_arguments_ref_name_struct_ref["${_TASK_NAME_FIELD}"]}"
        return 1
    fi
}

function project:task.get_fileset() {
    local -n get_fileset_struct_ref="${1}"
    shift

    if [[ -v get_fileset_struct_ref["${_TASK_FILESET_FIELD}"] ]]; then
        echo "${get_fileset_struct_ref["${_TASK_FILESET_FIELD}"]}"
        return 0
    else
        mycmd.trace "No fileset defined for ${get_fileset_struct_ref["${_TASK_NAME_FIELD}"]}"
        return 1
    fi
}

function project:task.get_arguments() {
    local -n get_arguments_struct_ref="${1}"
    local -n get_arguments_arguments_ref="${2}"
    shift 2

    local -r task_name="${get_arguments_struct_ref["${_TASK_NAME_FIELD}"]}"

    local -i argc
    argc="${get_arguments_struct_ref["${_TASK_ARGUMENT_COUNT_FIELD}"]}"
    readonly argc

    if ((argc == 0)); then
        mycmd.trace "No arguments defined for task '${task_name}'."
        return 0
    fi

    local -i index
    index="${get_arguments_struct_ref["${_TASK_ARGUMENT_INDEX_FIELD}"]}"
    readonly index

    local -n arguments_ref="${get_arguments_struct_ref["${_TASK_ARGUMENTS_REF_NAME_FIELD}"]}"

    get_arguments_arguments_ref=("${arguments_ref[@]:index:argc}")
}

function project:task.new_unregistered_zero_arg_task() {
    local -r task_name="${1}"
    local -n new_unregistered_task_struct_ref="${2}"

    mycmd.trace "Returning unregistered zero argument task definition:"
    new_unregistered_task_struct_ref["${_TASK_NAME_FIELD}"]="${task_name}"
    mycmd.trace "- ${_TASK_NAME_FIELD}: ${new_unregistered_task_struct_ref["${_TASK_NAME_FIELD}"]}"

    new_unregistered_task_struct_ref["${_TASK_FUNCTION_FIELD}"]=execute_task
    mycmd.trace "- ${_TASK_FUNCTION_FIELD}: ${new_unregistered_task_struct_ref["${_TASK_FUNCTION_FIELD}"]}"

    new_unregistered_task_struct_ref["${_TASK_ARGUMENT_COUNT_FIELD}"]=0
    mycmd.trace "- ${_TASK_ARGUMENT_COUNT_FIELD}: ${new_unregistered_task_struct_ref["${_TASK_ARGUMENT_COUNT_FIELD}"]}"

    mycmd.trace "- ${_TASK_ARGUMENT_INDEX_FIELD}: No index set"
    mycmd.trace "- ${_TASK_ARGUMENTS_REF_NAME_FIELD}: No task arguments ref names ref set"
    mycmd.trace "- ${_TASK_FILESET_FIELD}: No fileset set"
}

mycmd.trace "The MyCmd Project Command Group Task support library has been sourced."

# -*- mode: shell-script; sh-shell: bash; sh-basic-offset: 4; sh-indentation: 4; coding: utf-8 -*-
# shellcheck shell=bash

# MyCmd Command Group Support Library
#   Support for Command Group Data Structures and Related Functions for MyCmd

set -o nounset -o errexit -o errtrace -o pipefail

(return 0 >/dev/null 2>&1) || {
    echo >&2 "$0 is a library only meant to be sourced."
    exit 1
}

[[ -n "${_MYCMD_COMMAND_GROUP_LIB:-}" ]] && return
readonly _MYCMD_COMMAND_GROUP_LIB=1

if [[ ! -v _MYCMD_LIB_DIR ]]; then
    readonly _MYCMD_COMMAND_GROUP_LIB_SELF_FILE="${BASH_SOURCE[0]}"
    _MYCMD_LIB_DIR=$(cd "$(dirname "${_MYCMD_COMMAND_GROUP_LIB_SELF_FILE}")" &>/dev/null && pwd -P)
    readonly _MYCMD_LIB_DIR
fi

# ------------------------------------------------------------------------------
# Source Required Support Libraries

if [[ ! -v _MYCMD_LOADING_LIB ]]; then
    # shellcheck source=./mycmd-loading-lib
    source "${_MYCMD_LIB_DIR}/mycmd-loading-lib"
fi

mycmd.load_mycmd_lib_support_lib "event-lifecycle"
mycmd.load_mycmd_lib_support_lib "output"
mycmd.load_mycmd_lib_support_lib "pathname"

# A Command Group has:
# - A Name: import
# - A Fully Qualifield Name - `mycmd/financial/import`
# - Namespaced Parts - [mycmd, financial, import]
# - A Source Directory - $HOME/mycmd/financial/import/
# - A Source File - $HOME/mycmd/financial/import/import-lib
# - Any number of commands
# - Any number of child command groups
# - A short description used in help
# - A long description used in help
# - A version string used in help

# Global Data Structures, all keyed by the fully qualified name
# - Command Group Source Directories
declare -Agx _MYCMD_COMMAND_GROUP_SOURCE_DIRECTORIES=()
# - Command Group Source Files
declare -Agx _MYCMD_COMMAND_GROUP_SOURCE_FILES=()
# - Command Group Short Descriptions
declare -Agx _MYCMD_COMMAND_GROUP_SHORT_DESCS=()
# - Command Group Long Descriptions
declare -Agx _MYCMD_COMMAND_GROUP_LONG_DESCS=()
# - Command Group Versions
declare -Agx _MYCMD_COMMAND_GROUP_VERSIONS=()

# Command Group Data Structure
readonly _COMMAND_GROUP_NAME_FIELD='command-group-name'
readonly _COMMAND_GROUP_FULLY_QUALIFIED_NAME_FIELD='command-group-fully-qualified-name'
readonly _COMMAND_GROUP_SOURCE_DIRECTORY_FIELD='command-group-source-directory'
readonly _COMMAND_GROUP_SOURCE_FILE_FIELD='command-group-source-file'
readonly _COMMAND_GROUP_SHORT_DESC_FIELD='command-group-short-description'
readonly _COMMAND_GROUP_LONG_DESC_FIELD='command-group-long-description'
readonly _COMMAND_GROUP_VERSION_FIELD='command-group-version'

function mycmd:command_group.source_file_path_for_directory() {
    local -r potential_command_group="${1}"

    local name
    if ! name="$(basename "${potential_command_group}")"; then
        mycmd.debug "Error getting basename of '${potential_command_group}'."
        return 1
    fi
    readonly name

    local -r source_file_name="${potential_command_group}/${name}-lib"
    echo "${source_file_name}"
    return 0
}

function mycmd:command_group.directory_contains_command_group() {
    # A directory is a command group if:
    # - it is valid directory
    # - it is a child of one of the top-level MyCmd directories on the path
    # - it has a file named <command-group>/<command-group>-lib matching the directory
    local -r potential_command_group="${1}"

    if ! mycmd:pathname.is_valid_absolute_path_of_directory "${potential_command_group}"; then
        mycmd.debug "${potential_command_group} is not a valid absolute path of a directory."
        return 1
    fi

    if ! mycmd:pathname.is_child_of_mycmd_path_directory "${potential_command_group}"; then
        mycmd.debug "${potential_command_group} is not a descendant of any of the MyCmd base directories."
        return 1
    fi

    local source_file_path
    if ! source_file_path="$(mycmd:command_group.source_file_path_for_directory "${potential_command_group}")"; then
        mycmd.debug "Error getting source file name for command group library '${potential_command_group}'."
        return 1
    fi
    readonly source_file_path

    if [[ ! -f "${source_file_path}" ]]; then
        mycmd.debug "Expected command group library file '${source_file_path}' does not exist."
        return 1
    fi

    return 0
}

function mycmd:command_group.register_command_group() {
    local -r potential_command_group="${1}"

    if ! mycmd:command_group.directory_contains_command_group "${potential_command_group}"; then
        mycmd.debug "Directory ${potential_command_group} does not contain a command group."
        return 1
    fi

    local fully_qualified_name
    if ! fully_qualified_name="$(mycmd:pathname.fully_qualified_name_for_path "${potential_command_group}")"; then
        mycmd.debug "Error getting fully qualified name for ${potential_command_group}."
        return 1
    fi
    readonly fully_qualified_name

    if [[ -v _MYCMD_COMMAND_GROUP_SOURCE_DIRECTORIES["${fully_qualified_name}"] ]]; then
        if [[ "${_MYCMD_COMMAND_GROUP_SOURCE_DIRECTORIES["${fully_qualified_name}"]}" == "${potential_command_group}" ]]; then
            mycmd.debug "Command group ${fully_qualified_name} has already been loaded."
            return 0
        else
            mycmd.debug "Command group ${fully_qualified_name} has already been loaded, but with a different path: ${_MYCMD_COMMAND_GROUP_SOURCE_DIRECTORIES["${fully_qualified_name}"]}"
            return 1
        fi
    fi

    local source_file_path
    if ! source_file_path="$(mycmd:command_group.source_file_path_for_directory "${potential_command_group}")"; then
        mycmd.debug "Error getting source file name for command group library '${potential_command_group}'."
        return 1
    fi
    readonly source_file_path

    _MYCMD_COMMAND_GROUP_SOURCE_DIRECTORIES["${fully_qualified_name}"]="${potential_command_group}"
    _MYCMD_COMMAND_GROUP_SOURCE_FILES["${fully_qualified_name}"]="${source_file_path}"

    # TODO: Load the command group file to get the help and version information
    return 0
}

function mycmd:command_group._dump_assoc_array() {
    declare -Agx | grep "${1}"
}

function mycmd:command_group._dump_source_data() {
    mycmd:command_group._dump_assoc_array _MYCMD_COMMAND_GROUP_SOURCE_DIRECTORIES
    mycmd:command_group._dump_assoc_array _MYCMD_COMMAND_GROUP_SOURCE_FILES
    mycmd:command_group._dump_assoc_array _MYCMD_COMMAND_GROUP_LONG_DESCS
    mycmd:command_group._dump_assoc_array _MYCMD_COMMAND_GROUP_VERSIONS
}

function mycmd:command_group.get_command_group() {
    local -r command_group_fq_name="${1}"
    local -n command_group_struct_ref="${2}"

    if [[ ! -v _MYCMD_COMMAND_GROUP_SOURCE_FILES[${command_group_fq_name}] ]]; then
        mycmd.log "Unknown command group: '${command_group_fq_name}'."
        return 1
    fi

    mycmd.trace "Returning Command Group definition:"
    command_group_struct_ref["${_COMMAND_GROUP_NAME_FIELD}"]="$(basename "${command_group_fq_name}")"
    mycmd.trace "- ${_COMMAND_GROUP_NAME_FIELD}: ${command_group_struct_ref["${_COMMAND_GROUP_NAME_FIELD}"]}"

    command_group_struct_ref["${_COMMAND_GROUP_FULLY_QUALIFIED_NAME_FIELD}"]="${command_group_fq_name}"
    mycmd.trace "- ${_COMMAND_GROUP_FULLY_QUALIFIED_NAME_FIELD}: ${command_group_struct_ref["${_COMMAND_GROUP_FULLY_QUALIFIED_NAME_FIELD}"]}"

    command_group_struct_ref["${_COMMAND_GROUP_SOURCE_DIRECTORY_FIELD}"]="${_MYCMD_COMMAND_GROUP_SOURCE_DIRECTORIES["${command_group_fq_name}"]}"
    mycmd.trace "- ${_COMMAND_GROUP_SOURCE_DIRECTORY_FIELD}: ${command_group_struct_ref["${_COMMAND_GROUP_SOURCE_DIRECTORY_FIELD}"]}"

    command_group_struct_ref["${_COMMAND_GROUP_SOURCE_FILE_FIELD}"]="${_MYCMD_COMMAND_GROUP_SOURCE_FILES["${command_group_fq_name}"]}"
    mycmd.trace "- ${_COMMAND_GROUP_SOURCE_FILE_FIELD}: ${command_group_struct_ref["${_COMMAND_GROUP_SOURCE_FILE_FIELD}"]}"

    if [[ -v _MYCMD_COMMAND_GROUP_SHORT_DESCS[${command_group_fq_name}] ]]; then
        command_group_struct_ref["${_COMMAND_GROUP_SHORT_DESC_FIELD}"]="${_MYCMD_COMMAND_GROUP_SHORT_DESCS["${command_group_fq_name}"]}"
        mycmd.trace "- ${_COMMAND_GROUP_SHORT_DESC_FIELD}: ${command_group_struct_ref["${_COMMAND_GROUP_SHORT_DESC_FIELD}"]}"
    else
        mycmd.trace "- ${_COMMAND_GROUP_SHORT_DESC_FIELD}: No value set."
    fi

    if [[ -v _MYCMD_COMMAND_GROUP_LONG_DESCS[${command_group_fq_name}] ]]; then
        command_group_struct_ref["${_COMMAND_GROUP_LONG_DESC_FIELD}"]="${_MYCMD_COMMAND_GROUP_LONG_DESCS["${command_group_fq_name}"]}"
        mycmd.trace "- ${_COMMAND_GROUP_LONG_DESC_FIELD}: ${command_group_struct_ref["${_COMMAND_GROUP_LONG_DESC_FIELD}"]}"
    else
        mycmd.trace "- ${_COMMAND_GROUP_LONG_DESC_FIELD}: No value set."
    fi

    if [[ -v _MYCMD_COMMAND_GROUP_VERSIONS[${command_group_fq_name}] ]]; then
        command_group_struct_ref["${_COMMAND_GROUP_VERSION_FIELD}"]="${_MYCMD_COMMAND_GROUP_VERSIONS["${command_group_fq_name}"]}"
        mycmd.trace "- ${_COMMAND_GROUP_VERSION_FIELD}: ${command_group_struct_ref["${_COMMAND_GROUP_VERSION_FIELD}"]}"
    else
        mycmd.trace "- ${_COMMAND_GROUP_VERSION_FIELD}: No value set."
    fi
}

function mycmd:command_group._get_required_field_from_command_group_struct() {
    local -r field_name="${1}"
    # shellcheck disable=SC2178
    local -n command_group_struct_ref="${2}"

    echo "${command_group_struct_ref["${field_name}"]}"
}

function mycmd:command_group._get_optional_field_from_command_group_struct() {
    local -r field_name="${1}"
    # shellcheck disable=SC2178
    local -n command_group_struct_ref="${2}"

    if [[ -v command_group_struct_ref["${field_name}"] ]]; then
        echo "${command_group_struct_ref["${field_name}"]}"
        return 0
    else
        local command_group_fq_name
        command_group_fq_name="$(mycmd:command_group.get_fully_qualified_name "${!command_group_struct_ref}")"
        readonly command_group_fq_name
        mycmd.trace "No value for '${field_name}' defined for command group '${command_group_fq_name}'."
        return 1
    fi
}

function mycmd:command_group.get_name() {
    mycmd:command_group._get_required_field_from_command_group_struct \
        "${_COMMAND_GROUP_NAME_FIELD}" \
        "${@}"
}

function mycmd:command_group.get_fully_qualified_name() {
    mycmd:command_group._get_required_field_from_command_group_struct \
        "${_COMMAND_GROUP_FULLY_QUALIFIED_NAME_FIELD}" \
        "${@}"
}

function mycmd:command_group.get_parent_tree() {
    # shellcheck disable=SC2178
    local -n command_group_struct_ref="${1}"
    local -n parent_tree_ref="${2}"

    parent_tree_ref=()

    local fully_qualified_name
    fully_qualified_name="$(mycmd:command_group.get_fully_qualified_name "${@}")"
    readonly fully_qualified_name

    local namespaced_parts
    # shellcheck disable=SC2162
    IFS="/" read -a namespaced_parts <<<"${fully_qualified_name}"
    readonly namespaced_parts

    local command_group_name=""
    local part

    for part in "${namespaced_parts[@]}"; do
        command_group_name="${command_group_name}${command_group_name:+/}${part}"

        parent_tree_ref+=("${command_group_name}")
    done
}

function mycmd:command_group.get_namespaced_parts_as_string() {
    local fully_qualified_name
    fully_qualified_name="$(mycmd:command_group.get_fully_qualified_name "${@}")"
    readonly fully_qualified_name

    local -r namespaced_parts="${fully_qualified_name//\// }"
    echo "${namespaced_parts}"
}

function mycmd:command_group.get_source_directory() {
    mycmd:command_group._get_required_field_from_command_group_struct \
        "${_COMMAND_GROUP_SOURCE_DIRECTORY_FIELD}" \
        "${@}"
}

function mycmd:command_group.get_source_file() {
    mycmd:command_group._get_required_field_from_command_group_struct \
        "${_COMMAND_GROUP_SOURCE_FILE_FIELD}" \
        "${@}"
}

function mycmd:command_group.get_short_description() {
    local short_description

    if short_description="$(mycmd:command_group._get_optional_field_from_command_group_struct \
        "${_COMMAND_GROUP_SHORT_DESC_FIELD}" \
        "${@}")"; then
        readonly short_description
    else
        local namespaced_parts
        namespaced_parts="$(mycmd:command_group.get_namespaced_parts_as_string "${@}")"
        readonly namespaced_parts
        short_description="MyCmd Command Group ${namespaced_parts}"
        readonly short_description
    fi

    echo "${short_description}"
    return 0
}

function mycmd:command_group.get_long_description() {
    mycmd:command_group._get_optional_field_from_command_group_struct \
        "${_COMMAND_GROUP_LONG_DESC_FIELD}" \
        "${@}"
}

function mycmd:command_group.get_version() {
    local version

    if version="$(mycmd:command_group._get_optional_field_from_command_group_struct \
        "${_COMMAND_GROUP_VERSION_FIELD}" \
        "${@}")"; then
        echo "${version}"
        return 0
    else
        echo "Unknown"
        return 0
    fi
}

mycmd.trace "The MyCmd Command Group support library has been sourced."

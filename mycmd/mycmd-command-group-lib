# -*- mode: shell-script; sh-shell: bash; sh-basic-offset: 4; sh-indentation: 4; coding: utf-8 -*-
# shellcheck shell=bash

# MyCmd Command Group Support Library
#   Support for Command Group Data Structures and Related Functions for MyCmd

set -o nounset -o errexit -o errtrace -o pipefail

(return 0 >/dev/null 2>&1) || {
    echo >&2 "$0 is a library only meant to be sourced."
    exit 1
}

[[ -n "${_MYCMD_COMMAND_GROUP_LIB:-}" ]] && return
readonly _MYCMD_COMMAND_GROUP_LIB=1

if [[ ! -v _MYCMD_LIB_DIR ]]; then
    readonly _MYCMD_COMMAND_GROUP_LIB_SELF_FILE="${BASH_SOURCE[0]}"
    _MYCMD_LIB_DIR=$(cd "$(dirname "${_MYCMD_COMMAND_GROUP_LIB_SELF_FILE}")" &>/dev/null && pwd -P)
    readonly _MYCMD_LIB_DIR
fi

# ------------------------------------------------------------------------------
# Source Required Support Libraries
if [[ ! -v _MYCMD_LOADING_LIB ]]; then
    # shellcheck source=./mycmd-loading-lib
    source "${_MYCMD_LIB_DIR}/mycmd-loading-lib"
fi

mycmd.load_mycmd_lib_support_lib "event-lifecycle"
mycmd.load_mycmd_lib_support_lib "function-calling"
mycmd.load_mycmd_lib_support_lib "output"
mycmd.load_mycmd_lib_support_lib "pathname"

# A Command Group has:
# - A Name: import
# - A Fully Qualifield Name - `mycmd/financial/import`
# - Namespaced Parts - [mycmd, financial, import]
# - A Source Directory - $HOME/mycmd/financial/import/
# - A Source File - $HOME/mycmd/financial/import/import-lib
# - Any number of commands
# - Any number of child command groups
# - A short description used in help
# - A long description used in help
# - A version string used in help

# Global Data Structures
# - All Registered Command Group Names
declare -agx _MYCMD_COMMAND_GROUPS=()
# The rest are all keyed by the fully qualified name
# - Command Group Source Directories
declare -Agx _MYCMD_COMMAND_GROUP_SOURCE_DIRECTORIES=()
# - Command Group Source Files
declare -Agx _MYCMD_COMMAND_GROUP_SOURCE_FILES=()
# - Command Group Short Descriptions
declare -Agx _MYCMD_COMMAND_GROUP_SHORT_DESCS=()
# - Command Group Long Descriptions
declare -Agx _MYCMD_COMMAND_GROUP_LONG_DESCS=()
# - Command Group Versions
declare -Agx _MYCMD_COMMAND_GROUP_VERSIONS=()
# - Command Groups with fully loaded metadata
declare -Agx _MYCMD_COMMAND_GROUP_METADATA_LOADED=()

# TODO: Handle this cleaner, but this is to avoid trying to load mycmd-lib
_MYCMD_COMMAND_GROUP_METADATA_LOADED["mycmd"]=1

# Command Group Data Structure
readonly _COMMAND_GROUP_NAME_FIELD='command-group-name'
readonly _COMMAND_GROUP_FULLY_QUALIFIED_NAME_FIELD='command-group-fully-qualified-name'
readonly _COMMAND_GROUP_SOURCE_DIRECTORY_FIELD='command-group-source-directory'
readonly _COMMAND_GROUP_SOURCE_FILE_FIELD='command-group-source-file'
readonly _COMMAND_GROUP_SHORT_DESC_FIELD='command-group-short-description'
readonly _COMMAND_GROUP_LONG_DESC_FIELD='command-group-long-description'
readonly _COMMAND_GROUP_VERSION_FIELD='command-group-version'
readonly _COMMAND_GROUP_METADATA_LOADED_FIELD='command-group-metadata-loaded'

function mycmd:command_group.source_file_path_for_directory() {
    local -r potential_command_group="${1}"

    local name
    if ! name="$(basename "${potential_command_group}")"; then
        mycmd.debug "Error getting basename of '${potential_command_group}'."
        return 1
    fi
    readonly name

    local -r source_file_name="${potential_command_group}/${name}-lib"
    echo "${source_file_name}"
    return 0
}

function mycmd:command_group.validate_directory_contains_command_group() {
    # A directory is a command group if:
    # - it is valid directory
    # - it is a child of one of the top-level MyCmd directories on the path
    # - it has a file named <command-group>/<command-group>-lib matching the directory
    local -r potential_command_group="${1}"

    if ! mycmd:pathname.is_valid_absolute_path_of_directory "${potential_command_group}"; then
        mycmd.debug "${potential_command_group} is not a valid absolute path of a directory."
        return 1
    fi

    if ! mycmd:pathname.is_child_of_mycmd_path_directory "${potential_command_group}"; then
        mycmd.debug "${potential_command_group} is not a descendant of any of the MyCmd base directories."
        return 1
    fi

    local source_file_path
    if ! source_file_path="$(mycmd:command_group.source_file_path_for_directory "${potential_command_group}")"; then
        mycmd.debug "Error getting source file name for command group library '${potential_command_group}'."
        return 1
    fi
    readonly source_file_path

    if [[ ! -f "${source_file_path}" ]]; then
        mycmd.debug "Expected command group library file '${source_file_path}' does not exist."
        return 1
    fi

    return 0
}

function mycmd:command_group.register_version() {
    if [[ ! -v _MYCMD_SOURCING_COMMAND_GROUP_FOR_HELP && ! -v _MYCMD_COMMAND_GROUP_FULLY_QUALIFIED_NAME ]]; then
        mycmd.debug "This should only be called when sourcing a command group for registering versions."
        return 1
    fi

    local -r version="${1}"
    _MYCMD_COMMAND_GROUP_VERSIONS["${_MYCMD_COMMAND_GROUP_FULLY_QUALIFIED_NAME}"]="${version}"

    return 0
}

function mycmd:command_group.register_short_description() {
    if [[ ! -v _MYCMD_SOURCING_COMMAND_GROUP_FOR_HELP && ! -v _MYCMD_COMMAND_GROUP_FULLY_QUALIFIED_NAME ]]; then
        mycmd.debug "This should only be called when sourcing a command group for registering help."
        return 1
    fi

    local -r short_description="${1}"
    _MYCMD_COMMAND_GROUP_SHORT_DESCS["${_MYCMD_COMMAND_GROUP_FULLY_QUALIFIED_NAME}"]="${short_description}"

    return 0
}

# TODO: How should I handle multiple line help messages?
function mycmd:command_group.register_long_description() {
    if [[ ! -v _MYCMD_SOURCING_COMMAND_GROUP_FOR_HELP && ! -v _MYCMD_COMMAND_GROUP_FULLY_QUALIFIED_NAME ]]; then
        mycmd.debug "This should only be called when sourcing a command group for registering help."
        return 1
    fi

    local -r long_descripption="${1}"
    _MYCMD_COMMAND_GROUP_LONG_DESCS["${_MYCMD_COMMAND_GROUP_FULLY_QUALIFIED_NAME}"]="${long_descripption}"

    return 0
}

function mycmd:command_group._load_command_group_help_and_version() {
    local -r fully_qualified_name="${1}"
    local -r source_file_path="${2}"

    mycmd.trace "Loading help and version information for command group '${fully_qualified_name}' at file '${source_file_path}'."

    declare -gx _MYCMD_COMMAND_GROUP_FULLY_QUALIFIED_NAME="${fully_qualified_name}"
    declare -gx _MYCMD_SOURCING_COMMAND_GROUP_FOR_HELP=1
    if ! mycmd.source_lib_by_path_if_found "${source_file_path}"; then
        mycmd.debug "Error loading command group help and version information from '${source_file_path}'."
        return 1
    fi
    unset _MYCMD_SOURCING_COMMAND_GROUP_FOR_HELP
    unset _MYCMD_COMMAND_GROUP_FULLY_QUALIFIED_NAME

    _MYCMD_COMMAND_GROUP_METADATA_LOADED["${fully_qualified_name}"]=1

    return 0
}

function mycmd:command_group.register_mycmd_version_and_descriptions() {
    local -r version="${1}"
    local -r short_description="${2}"
    local -r long_description="${3}"

    declare -gx _MYCMD_COMMAND_GROUP_FULLY_QUALIFIED_NAME="mycmd"
    declare -gx _MYCMD_SOURCING_COMMAND_GROUP_FOR_HELP=1

    mycmd:command_group.register_version "${version}"
    mycmd:command_group.register_short_description "${short_description}"
    mycmd:command_group.register_long_description "${long_description}"

    unset _MYCMD_SOURCING_COMMAND_GROUP_FOR_HELP
    unset _MYCMD_COMMAND_GROUP_FULLY_QUALIFIED_NAME

    _MYCMD_COMMAND_GROUP_METADATA_LOADED["mycmd"]=1

    return 0
}

function mycmd:command_group.register_command_group() {
    local -r potential_command_group="${1}"
    local -r fully_qualified_name="${2}"

    # If this is called by mycmd:pathname.walk_path, assuming directory paths are real and on the MyCmd Search Path
    if mycmd.is_called_by_function "mycmd:pathname.walk_path"; then
        mycmd.trace "Skipping validation of parameters, assuming they are valid, as called from 'mycmd:pathname.walk_path'."
    else
        if ! mycmd:command_group.validate_directory_contains_command_group "${potential_command_group}"; then
            mycmd.debug "Directory ${potential_command_group} does not contain a command group."
            return 0
        fi
    fi

    local source_file_path
    if ! source_file_path="$(mycmd:command_group.source_file_path_for_directory "${potential_command_group}")"; then
        mycmd.debug "Error getting source file name for command group library '${potential_command_group}'."
        return 1
    fi
    readonly source_file_path

    if [[ ! -e "${source_file_path}" ]]; then
        mycmd.debug "Expected command group library file '${source_file_path}' does not exist, '${fully_qualified_name}' is not a command group."
        return 0
    fi

    if [[ -v _MYCMD_COMMAND_GROUP_SOURCE_DIRECTORIES["${fully_qualified_name}"] ]]; then
        if [[ "${_MYCMD_COMMAND_GROUP_SOURCE_DIRECTORIES["${fully_qualified_name}"]}" == "${potential_command_group}" ]]; then
            mycmd.debug "Command group ${fully_qualified_name} has already been loaded."
            return 0
        else
            mycmd.debug "Command group ${fully_qualified_name} has already been loaded, but with a different path: ${_MYCMD_COMMAND_GROUP_SOURCE_DIRECTORIES["${fully_qualified_name}"]}"
            return 1
        fi
    fi

    _MYCMD_COMMAND_GROUP_SOURCE_DIRECTORIES["${fully_qualified_name}"]="${potential_command_group}"
    _MYCMD_COMMAND_GROUP_SOURCE_FILES["${fully_qualified_name}"]="${source_file_path}"
    _MYCMD_COMMAND_GROUPS+=("${fully_qualified_name}")

    return 0
}

function mycmd:command_group._dump_assoc_array() {
    declare -Agx | grep "${1}"
}

function mycmd:command_group._dump_source_data() {
    mycmd:command_group._dump_assoc_array _MYCMD_COMMAND_GROUP_SOURCE_DIRECTORIES
    mycmd:command_group._dump_assoc_array _MYCMD_COMMAND_GROUP_SOURCE_FILES
    mycmd:command_group._dump_assoc_array _MYCMD_COMMAND_GROUP_LONG_DESCS
    mycmd:command_group._dump_assoc_array _MYCMD_COMMAND_GROUP_VERSIONS
}

function mycmd:command_group.get_command_group() {
    local -r command_group_fq_name="${1}"
    local -n command_group_struct_ref="${2}"

    if [[ ! -v _MYCMD_COMMAND_GROUP_SOURCE_FILES[${command_group_fq_name}] ]]; then
        mycmd.log "Unknown command group: '${command_group_fq_name}'."
        return 1
    fi

    mycmd.trace "Returning Command Group definition:"
    command_group_struct_ref["${_COMMAND_GROUP_NAME_FIELD}"]="$(basename "${command_group_fq_name}")"
    mycmd.trace "- ${_COMMAND_GROUP_NAME_FIELD}: ${command_group_struct_ref["${_COMMAND_GROUP_NAME_FIELD}"]}"

    command_group_struct_ref["${_COMMAND_GROUP_FULLY_QUALIFIED_NAME_FIELD}"]="${command_group_fq_name}"
    mycmd.trace "- ${_COMMAND_GROUP_FULLY_QUALIFIED_NAME_FIELD}: ${command_group_struct_ref["${_COMMAND_GROUP_FULLY_QUALIFIED_NAME_FIELD}"]}"

    command_group_struct_ref["${_COMMAND_GROUP_SOURCE_DIRECTORY_FIELD}"]="${_MYCMD_COMMAND_GROUP_SOURCE_DIRECTORIES["${command_group_fq_name}"]}"
    mycmd.trace "- ${_COMMAND_GROUP_SOURCE_DIRECTORY_FIELD}: ${command_group_struct_ref["${_COMMAND_GROUP_SOURCE_DIRECTORY_FIELD}"]}"

    command_group_struct_ref["${_COMMAND_GROUP_SOURCE_FILE_FIELD}"]="${_MYCMD_COMMAND_GROUP_SOURCE_FILES["${command_group_fq_name}"]}"
    mycmd.trace "- ${_COMMAND_GROUP_SOURCE_FILE_FIELD}: ${command_group_struct_ref["${_COMMAND_GROUP_SOURCE_FILE_FIELD}"]}"

    if [[ -v _MYCMD_COMMAND_GROUP_SHORT_DESCS[${command_group_fq_name}] ]]; then
        command_group_struct_ref["${_COMMAND_GROUP_SHORT_DESC_FIELD}"]="${_MYCMD_COMMAND_GROUP_SHORT_DESCS["${command_group_fq_name}"]}"
        mycmd.trace "- ${_COMMAND_GROUP_SHORT_DESC_FIELD}: ${command_group_struct_ref["${_COMMAND_GROUP_SHORT_DESC_FIELD}"]}"
    else
        mycmd.trace "- ${_COMMAND_GROUP_SHORT_DESC_FIELD}: No value set."
    fi

    if [[ -v _MYCMD_COMMAND_GROUP_LONG_DESCS[${command_group_fq_name}] ]]; then
        command_group_struct_ref["${_COMMAND_GROUP_LONG_DESC_FIELD}"]="${_MYCMD_COMMAND_GROUP_LONG_DESCS["${command_group_fq_name}"]}"
        mycmd.trace "- ${_COMMAND_GROUP_LONG_DESC_FIELD}: ${command_group_struct_ref["${_COMMAND_GROUP_LONG_DESC_FIELD}"]}"
    else
        mycmd.trace "- ${_COMMAND_GROUP_LONG_DESC_FIELD}: No value set."
    fi

    if [[ -v _MYCMD_COMMAND_GROUP_VERSIONS[${command_group_fq_name}] ]]; then
        command_group_struct_ref["${_COMMAND_GROUP_VERSION_FIELD}"]="${_MYCMD_COMMAND_GROUP_VERSIONS["${command_group_fq_name}"]}"
        mycmd.trace "- ${_COMMAND_GROUP_VERSION_FIELD}: ${command_group_struct_ref["${_COMMAND_GROUP_VERSION_FIELD}"]}"
    else
        mycmd.trace "- ${_COMMAND_GROUP_VERSION_FIELD}: No value set."
    fi

    if [[ -v _MYCMD_COMMAND_GROUP_METADATA_LOADED[${command_group_fq_name}] ]]; then
        command_group_struct_ref["${_COMMAND_GROUP_METADATA_LOADED_FIELD}"]=1
        mycmd.trace "- Command Group metadata has been loaded."
    else
        command_group_struct_ref["${_COMMAND_GROUP_METADATA_LOADED_FIELD}"]=0
        mycmd.trace "- Command Group metadata has not been loaded."
    fi
}

function mycmd:command_group._get_required_field_from_command_group_struct() {
    local -r field_name="${1}"
    # shellcheck disable=SC2178
    local -n command_group_struct_ref="${2}"

    echo "${command_group_struct_ref["${field_name}"]}"
}

function mycmd:command_group.load_command_group_help_and_version() {
    # shellcheck disable=SC2178
    local -n command_group_struct_ref="${1}"

    if ! mycmd:command_group.is_metadata_loaded "${!command_group_struct_ref}"; then
        mycmd.trace "Command group metadata has not been loaded, so loading on demand."

        local command_group_fq_name
        command_group_fq_name="$(mycmd:command_group.get_fully_qualified_name "${!command_group_struct_ref}")"
        readonly command_group_fq_name

        local source_file_path
        source_file_path="$(mycmd:command_group.get_source_file "${!command_group_struct_ref}")"
        readonly source_file_path

        if ! mycmd:command_group._load_command_group_help_and_version "${command_group_fq_name}" "${source_file_path}"; then
            mycmd.debug "Error loading command group help and version information."
            return 1
        fi

        # Reload the command group struct to get the updated metadata
        mycmd:command_group.get_command_group "${command_group_fq_name}" "${!command_group_struct_ref}"
    fi

    return 0
}

function mycmd:command_group.is_metadata_loaded() {
    local is_metadata_loaded

    if ! is_metadata_loaded="$(mycmd:command_group._get_required_field_from_command_group_struct \
        "${_COMMAND_GROUP_METADATA_LOADED_FIELD}" \
        "${@}")"; then
        mycmd.debug "Error getting metadata loaded field from command group."
        return 1
    fi
    readonly is_metadata_loaded

    [[ "${is_metadata_loaded}" == "1" ]]
}

function mycmd:command_group._get_optional_field_from_command_group_struct() {
    local -r field_name="${1}"
    # shellcheck disable=SC2178
    local -n command_group_struct_ref="${2}"

    if ! mycmd:command_group.load_command_group_help_and_version "${!command_group_struct_ref}"; then
        mycmd.debug "Error loading command group help and version information."
        return 1
    fi

    if [[ -v command_group_struct_ref["${field_name}"] ]]; then
        echo "${command_group_struct_ref["${field_name}"]}"
        return 0
    else
        local command_group_fq_name
        command_group_fq_name="$(mycmd:command_group.get_fully_qualified_name "${!command_group_struct_ref}")"
        readonly command_group_fq_name
        mycmd.trace "No value for '${field_name}' defined for command group '${command_group_fq_name}'."
        return 1
    fi
}

function mycmd:command_group.get_name() {
    mycmd:command_group._get_required_field_from_command_group_struct \
        "${_COMMAND_GROUP_NAME_FIELD}" \
        "${@}"
}

function mycmd:command_group.get_fully_qualified_name() {
    mycmd:command_group._get_required_field_from_command_group_struct \
        "${_COMMAND_GROUP_FULLY_QUALIFIED_NAME_FIELD}" \
        "${@}"
}

function mycmd:command_group.get_parent_tree() {
    # shellcheck disable=SC2178
    local -n command_group_struct_ref="${1}"
    local -n parent_tree_ref="${2}"

    parent_tree_ref=()

    local fully_qualified_name
    fully_qualified_name="$(mycmd:command_group.get_fully_qualified_name "${@}")"
    readonly fully_qualified_name

    local namespaced_parts
    # shellcheck disable=SC2162
    IFS="/" read -a namespaced_parts <<<"${fully_qualified_name}"
    readonly namespaced_parts

    local command_group_name=""
    local part

    for part in "${namespaced_parts[@]}"; do
        command_group_name="${command_group_name}${command_group_name:+/}${part}"

        parent_tree_ref+=("${command_group_name}")
    done
}

function mycmd:command_group.get_namespaced_parts_as_string() {
    local fully_qualified_name
    fully_qualified_name="$(mycmd:command_group.get_fully_qualified_name "${@}")"
    readonly fully_qualified_name

    local -r namespaced_parts="${fully_qualified_name//\// }"
    echo "${namespaced_parts}"
}

function mycmd:command_group.get_source_directory() {
    mycmd:command_group._get_required_field_from_command_group_struct \
        "${_COMMAND_GROUP_SOURCE_DIRECTORY_FIELD}" \
        "${@}"
}

function mycmd:command_group.get_source_file() {
    mycmd:command_group._get_required_field_from_command_group_struct \
        "${_COMMAND_GROUP_SOURCE_FILE_FIELD}" \
        "${@}"
}

function mycmd:command_group.get_short_description() {
    local short_description

    if short_description="$(mycmd:command_group._get_optional_field_from_command_group_struct \
        "${_COMMAND_GROUP_SHORT_DESC_FIELD}" \
        "${@}")"; then
        readonly short_description
    else
        local namespaced_parts
        namespaced_parts="$(mycmd:command_group.get_namespaced_parts_as_string "${@}")"
        readonly namespaced_parts
        short_description="MyCmd Command Group ${namespaced_parts}"
        readonly short_description
    fi

    echo "${short_description}"
    return 0
}

function mycmd:command_group.get_long_description() {
    mycmd:command_group._get_optional_field_from_command_group_struct \
        "${_COMMAND_GROUP_LONG_DESC_FIELD}" \
        "${@}"
}

function mycmd:command_group.get_child_command_groups() {
    # shellcheck disable=SC2178
    local -n command_group_struct_ref="${1}"
    local -n child_command_groups_ref="${2}"

    local fully_qualified_name
    fully_qualified_name="$(mycmd:command_group.get_fully_qualified_name "${!command_group_struct_ref}")"
    readonly fully_qualified_name

    # shellcheck disable=SC2034
    readarray -t child_command_groups_ref < \
        <(printf '%s\n' "${_MYCMD_COMMAND_GROUPS[@]}" \
            | grep -E "^${fully_qualified_name}/[^/]+$" \
            | LC_ALL=en_US.UTF-8 sort || true)

    return 0
}

function mycmd:command_group.get_version() {
    local version

    if version="$(mycmd:command_group._get_optional_field_from_command_group_struct \
        "${_COMMAND_GROUP_VERSION_FIELD}" \
        "${@}")"; then
        echo "${version}"
        return 0
    else
        echo "Unknown"
        return 0
    fi
}

function mycmd:command_group.print_version() {
    # shellcheck disable=SC2178
    local -n command_group_struct_ref="${1}"

    if ! mycmd:command_group.load_command_group_help_and_version "${!command_group_struct_ref}"; then
        mycmd.debug "Error loading command group help and version information."
        return 1
    fi

    local namespaced_parts
    namespaced_parts="$(mycmd:command_group.get_namespaced_parts_as_string "${!command_group_struct_ref}")"
    readonly namespaced_parts

    local version
    version="$(mycmd:command_group.get_version "${!command_group_struct_ref}")"
    readonly version

    mycmd.output "${namespaced_parts} version ${version}"
}

function mycmd:command_group.print_short_description() {
    # shellcheck disable=SC2178
    local -n command_group_struct_ref="${1}"

    if ! mycmd:command_group.load_command_group_help_and_version "${!command_group_struct_ref}"; then
        mycmd.debug "Error loading command group help and version information."
        return 1
    fi

    local short_description
    short_description="$(mycmd:command_group.get_short_description "${!command_group_struct_ref}")"
    readonly short_description

    mycmd.output "${short_description}"
}

function mycmd:command_group.print_long_description() {
    # shellcheck disable=SC2178
    local -n command_group_struct_ref="${1}"

    if ! mycmd:command_group.load_command_group_help_and_version "${!command_group_struct_ref}"; then
        mycmd.debug "Error loading command group help and version information."
        return 1
    fi

    local long_description
    if ! long_description="$(mycmd:command_group.get_long_description "${!command_group_struct_ref}")"; then
        mycmd.debug "No long description provided"
        return 0
    fi
    readonly long_description

    mycmd.output "${long_description}"
}

mycmd.trace "The MyCmd Command Group support library has been sourced."

# -*- mode: shell-script; sh-shell: bash; sh-basic-offset: 4; sh-indentation: 4; coding: utf-8 -*-
# shellcheck shell=bash

# MyCmd Logging Command Group Library
#   Library for common routines for logging command output

# Set Bash options for safety
set -o nounset -o errexit -o errtrace -o pipefail

# This file should only be sourced and not executed directly, so exit with error
# with execution is attempted. Technique borrowed from
# https://stackoverflow.com/a/28776166
(return 0 >/dev/null 2>&1) || {
    echo >&2 "$0 is a library only meant to be sourced."
    exit 1
}

# This library should only be sourced once. Technique borrowed from
# https://stackoverflow.com/a/64534652
[[ -n "${_MYCMD_LOGGING_LIB:-}" ]] && return
readonly _MYCMD_LOGGING_LIB=1

mycmd.output "While sourcing:"
mycmd.log "This is logging output"

# This is needed to preserve the colors in any build output
mycmd.defer_at_startup mycmd.init_bin script
function logging._faketty() {
    local -r command="$(printf '%q ' "${@}")"

    if mycmd.is_mac_os; then
        mycmd.bin_execute script -q /dev/null "${BASH}" -c "${command}"
    else
        mycmd.bin_execute script -qefc "${BASH}" -c "${command}" /dev/null
    fi
}

# Captures both stderr and stdout, saving to the specified log file
function logging.capture_and_display() {
    # TODO Test that log file can be written
    local -r log_file=$1
    shift

    # For returning the exit code of the process being logged
    local exit_code=0

    { logging._faketty "${@}"; } 2>&1 | tee "${log_file}" || exit_code=$?

    return "${exit_code}"
}

mycmd.trace "The MyCmd Logging command group library has been sourced."

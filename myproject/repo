#!/usr/bin/env -S mycmd myproject run
# -*- mode: shell-script; sh-shell: bash; sh-basic-offset: 4; sh-indentation: 4; coding: utf-8 -*-
# shellcheck shell=bash

set -o nounset -o errexit -o errtrace -o pipefail

# --------------------------------------------------------------------------------------------------
# Git Repo Tasks
myproject.register_task_definition_file_description "Tasks for dealing with the MyCmd worktrees and snapshot git tags"

# --------------------------------------------------------------------------------------------------
# Global Dependencies
mycmd.trace "The following variables set in main are used in the test task definition file:"
# shellcheck disable=SC2154
mycmd.trace "- TMP_WORKING_DIR:        ${TMP_WORKING_DIR}"
# shellcheck disable=SC2154
mycmd.trace "- WORKTREES_PARENT_DIR:   ${WORKTREES_PARENT_DIR}"

readonly DIST_PARENT_DIR="${TMP_WORKING_DIR}/dist"

mycmd.trace "The following variables are defined here:"
mycmd.trace "- DIST_PARENT_DIR: ${DIST_PARENT_DIR}"

myproject.source_myproject_lib "git"

# --------------------------------------------------------------------------------------------------
# Local Snapshot Task Definitions

# Local Snapshots are:
# - used for testing changes locally
# - tags are not pushed to github
# - tag names are of the form 'local-snapshot-r0-2024-01-27'
readonly LOCAL_SNAPSHOT_TAG_PREFIX="local-snapshot"

function create_local_snapshot() {
    local commit
    if (($# == 0)); then
        commit="HEAD"
    else
        commit="${1}"
    fi
    readonly commit

    if git.commit_is_tagged_matching_pattern "${commit}" "${LOCAL_SNAPSHOT_TAG_PREFIX}-r.*"; then
        mycmd.error_output "Commit '${commit}' already has a snapshot defined."
        return 1
    fi

    local new_snapshot_tag_name
    if ! new_snapshot_tag_name="$(get_new_local_snapshot_tag_name)"; then
        mycmd.error_output "Error getting new snapshot tag name."
        return 1
    fi
    readonly new_snapshot_tag_name

    if ! git.create_lightweight_tag "${new_snapshot_tag_name}" "${commit}"; then
        mycmd.error_output "Error creating tag '${new_snapshot_tag_name}' at '${commit}'."
        return 1
    fi

    project.output_only_if_not_quiet "Created new local snapshot '${new_snapshot_tag_name}'."

    return 0
}

myproject.register_task create-local-snapshot create_local_snapshot
myproject.register_task_description create-local-snapshot "Create a local git snapshot tag."

function list_local_snapshots() {
    local -a tags=()
    get_local_snapshot_tags tags

    if (("${#tags[@]}" == 0)); then
        mycmd.output "There are no local snapshots defined."
    fi

    local tag
    for tag in "${tags[@]}"; do
        mycmd.output "${tag}"
    done
}

myproject.register_task list-local-snapshots list_local_snapshots
myproject.register_task_description list-local-snapshots "List all locally defined git snapshot tags."

# --------------------------------------------------------------------------------------------------
# Development Snapshot Task Definitions

# Development Snapshots
# - used for wider in-development testing
# - tags are pushed to github
# - tag names are of the form 'snapshot-r0-2024-01-27'
# - sequence numbers (r0 in this example) are independent of the local snapshot numbers
readonly DEVELOPMENT_SNAPSHOT_TAG_PREFIX='snapshot'

function list_development_snapshots() {
    local -a tags=()
    get_development_snapshot_tags tags

    if (("${#tags[@]}" == 0)); then
        mycmd.output "There are no development snapshots defined."
    fi

    local tag
    for tag in "${tags[@]}"; do
        mycmd.output "${tag}"
    done
}

myproject.register_task list-development-snapshots list_development_snapshots
myproject.register_task_description list-development-snapshots "List all development git snapshot tags."

function promote_local_snapshot_to_development() {
    if (($# == 0)); then
        mycmd.error_output "Missing snapshot to promote."
        return 1
    fi

    if ! mycmd.init_bin_no_exit gum; then
        mycmd.error_output "Required tool 'gum' not found."
        return 1
    fi

    local -r local_snapshot_tag="${1}"

    local new_development_snapshot_tag
    if ! new_development_snapshot_tag="$(get_new_development_snapshot_tag_name)"; then
        mycmd.error_output "Unexpected error getting new development snapshot tag name."
        return 1
    fi
    readonly new_development_snapshot_tag

    local -a tag_messages=()
    local summary_line
    if ! summary_line="$(mycmd.bin_execute gum input --placeholder "Summary of Snapshot")"; then
        mycmd.error_output "Error getting summary line."
        return 1
    fi
    tag_messages+=("${summary_line}")
    tag_messages+=("Created from local snapshot tag '${local_snapshot_tag}'.")

    if ! git.create_annotated_tag "${local_snapshot_tag}" "${new_development_snapshot_tag}" tag_messages; then
        mycmd.error_output "Error creating annotated tag"
        return 1
    fi

    if ! git.push_changes_with_annotated_tags; then
        mycmd.error_output "Error pushing changes"
        return 1
    fi

    project.output_only_if_not_quiet "Created and pushed new development snapshot '${new_development_snapshot_tag}'."
}

myproject.register_task promote-local-snapshot-to-development promote_local_snapshot_to_development
myproject.register_task_description promote-local-snapshot-to-development "Promote a locally defined git snapshot tag to a development snapshot tag."

function promote_latest_local_snapshot_tag_to_development() {
    local latest_local_snapshot
    if ! latest_local_snapshot="$(get_latest_local_snapshot_tag)"; then
        mycmd.error_output "No local snapshot tags defined yet."
        return 1
    fi
    readonly latest_local_snapshot

    promote_local_snapshot_to_development "${latest_local_snapshot}"
}

myproject.register_task promote-latest-local-snapshot-to-development promote_latest_local_snapshot_tag_to_development
myproject.register_task_description promote-latest-local-snapshot-to-development "Promote the latest locally defined git snapshot tag to a development snapshot tag."

# --------------------------------------------------------------------------------------------------
# Worktree Management Task Definitions
readonly SNAPSHOT_WORKTREE="${WORKTREES_PARENT_DIR}/snapshot"

function update_snapshot_worktree_to_snapshot() {
    local -r tag="${1}"
    local do_force
    if (($# > 1)); then
        do_force="${2}"
    fi
    readonly do_force

    if [[ -d "${SNAPSHOT_WORKTREE}" ]]; then
        local current_worktree_tag
        if ! current_worktree_tag="$(get_snapshot_worktree_current_tag)"; then
            mycmd.error_output "Unexpected error reading current snapshot worktree current tag file."
            return 1
        fi
        readonly current_worktree_tag

        if [[ "${current_worktree_tag}" = "${tag}" ]]; then
            if [[ "${do_force}" = "true" ]]; then
                mycmd.trace "Snapshot worktree is already at '${tag}'."
            else
                mycmd.output "Snapshot worktree is already at '${tag}'."
                return 0
            fi
        fi

        update_snapshot_worktree_last_used_tag_file "${current_worktree_tag}"
        git.update_worktree_to_commitish "${SNAPSHOT_WORKTREE}" "${tag}"
        update_snapshot_worktree_current_tag_file "${tag}"
    else
        git.add_worktree_at_detached_commit "${SNAPSHOT_WORKTREE}" "${tag}"
        update_snapshot_worktree_current_tag_file "${tag}"
    fi
}

myproject.register_task update-snapshot-worktree-to-snapshot update_snapshot_worktree_to_snapshot
myproject.register_task_description update-snapshot-worktree-to-snapshot "Update snapshot worktree checkout to specific snapshot git tag."

function update_snapshot_worktree_to_latest_local_snapshot() {
    local latest_local_snapshot
    if ! latest_local_snapshot="$(get_latest_local_snapshot_tag)"; then
        mycmd.error_output "No local snapshot tags defined yet."
        return 1
    fi
    readonly latest_local_snapshot

    update_snapshot_worktree_to_snapshot "${latest_local_snapshot}" "${@}"
}

myproject.register_task update-snapshot-worktree-to-latest-local-snapshot update_snapshot_worktree_to_latest_local_snapshot
myproject.register_task_description update-snapshot-worktree-to-latest-local-snapshot "Update snapshot worktree checkout to the latest local snapshot git tag."

function update_snapshot_worktree_to_latest_development_snapshot() {
    git.fetch_tags

    local latest_development_snapshot
    if ! latest_development_snapshot="$(get_latest_development_snapshot_tag)"; then
        mycmd.error_output "No development snapshot tags defined yet."
        return 1
    fi
    readonly latest_development_snapshot

    update_snapshot_worktree_to_snapshot "${latest_development_snapshot}" "${@}"
}

myproject.register_task update-snapshot-worktree-to-latest-development-snapshot update_snapshot_worktree_to_latest_development_snapshot
myproject.register_task_description update-snapshot-worktree-to-latest-development-snapshot "Update snapshot worktree checkout to the latest development snapshot git tag."

readonly SNAPSHOT_WORKTREE_LAST_USED_TAG_FILE="${WORKTREES_PARENT_DIR}/.last-used-snapshot-tag"
function rollback_snapshot_worktree_to_last_used_snapshot() {
    local last_used_tag
    if ! last_used_tag="$(get_snapshot_worktree_last_used_tag)"; then
        mycmd.error_output "No last used tag file found at '${SNAPSHOT_WORKTREE_LAST_USED_TAG_FILE}'."
        return 1
    fi
    readonly last_used_tag

    update_snapshot_worktree_to_snapshot "${last_used_tag}"
}

myproject.register_task rollback-snapshot-worktree-to-last-used-snapshot rollback_snapshot_worktree_to_last_used_snapshot
myproject.register_task_description rollback-snapshot-worktree-to-last-used-snapshot "Rollback snapshot worktree checkout to the last used snapshot git tag."

function rollback_snapshot_worktree_to_previous_snapshot_in_sequence() {
    local current_worktree_tag
    if ! current_worktree_tag="$(get_snapshot_worktree_current_tag)"; then
        mycmd.error_output "Error reading current snapshot worktree current tag file."
        return 1
    fi
    readonly current_worktree_tag

    local prior_snapshot_tag
    if ! prior_snapshot_tag="$(get_previous_snapshot_tag "${current_worktree_tag}")"; then
        return 1
    fi
    readonly prior_snapshot_tag

    update_snapshot_worktree_to_snapshot "${prior_snapshot_tag}"
}

myproject.register_task rollback-snapshot-worktree-to-previous-snapshot-in-sequence rollback_snapshot_worktree_to_previous_snapshot_in_sequence
myproject.register_task_description rollback-snapshot-worktree-to-previous-snapshot-in-sequence "Rollback the snapshot worktree checkout to the previous in sequence snapshot git tag."

# --------------------------------------------------------------------------------------------------
# Project Release Tasks

function clean_dist_directory() {
    if [[ -d "${DIST_PARENT_DIR}" ]]; then
        myproject.output_only_if_not_quiet "Cleaning up artifacts in dist directory '${DIST_PARENT_DIR}'."
        rm -rf "${DIST_PARENT_DIR:?}"/* || true
    fi
}

myproject.register_task clean-dist-directory clean_dist_directory
myproject.register_task_description clean-dist-directory "Clean the dist directory."

mycmd.add_to_init_bin_batch rsync

function create_release_tarball() {
    local -n release_artifacts_fileset="${1}"
    local -r release_name="${2}"
    local -r mycmd_release_name="mycmd-${release_name}"

    local -r release_dist_dir="${DIST_PARENT_DIR}/${mycmd_release_name}"

    if git.is_working_tree_dirty; then
        mycmd.error_output "There are unstaged changes, not creating a dist tarball."
        return 1
    fi

    if [[ -d "${release_dist_dir}" ]]; then
        mycmd.error_output "Release working directory '${release_dist_dir}' already exists, not overwriting."
        return 1
    else
        mkdir -p "${release_dist_dir}" || true
    fi

    myproject.output_only_if_not_quiet "Copying release artifacts to working directory: '${release_dist_dir}'."

    local src_dir
    for src_dir in "${release_artifacts_fileset[@]}"; do
        if ! mycmd.bin_execute rsync -a --exclude=".*" "${src_dir}" "${release_dist_dir}"; then
            mycmd.error_output "Error copying release artifacts from '${src_dir}' to dist directory."
            return 1
        fi
    done

    local release_tarball
    release_tarball="$(get_release_tarball_filename "${release_name}")"
    readonly release_tarball

    if ! tar_dist_directory "${mycmd_release_name}" "${release_tarball}"; then
        return 1
    fi
}

myproject.register_task_with_fileset create-release-tarball create_release_tarball RELEASE_ARTIFACTS
myproject.register_task_description create-release-tarball "Create a release tarball with the specified release name."

mycmd.add_to_init_bin_batch sed

function update_mycmd_version() {
    local -n fileset="${1}"
    local -r new_version="${2}"

    if git.is_working_tree_dirty; then
        mycmd.error_output "There are unstaged changes, not updating version information."
        return 1
    fi

    mycmd.bin_execute sed -i \
        -e "s/^mycmd:command\.register_version \".*\"/mycmd:command.register_version \"${new_version}\"/" \
        -e "s/^mycmd:command_group\.register_version \".*\"/mycmd:command_group.register_version \"${new_version}\"/" \
        -e "s/declare -rgx _MYCMD_VERSION=.*/declare -rgx _MYCMD_VERSION=\"${new_version}\"/" \
        "${fileset[@]}"

    if git.has_unstaged_changes_in_paths "${fileset[@]}"; then
        local -r message="Update MyCmd to version ${new_version}."

        if ! git.commit_changes_in_paths_with_message "${message}" "${fileset[@]}"; then
            return 1
        fi

        if ! git.push_changes_with_annotated_tags; then
            return 1
        fi
    fi
}

myproject.register_task_with_fileset update-mycmd-version update_mycmd_version IMPLEMENTATION_FILES
myproject.register_task_description update-mycmd-version "Update the MyCmd version string for MyCmd in the source."

function create_manual_github_release() {
    local -r release_name="${1}"

    local release_tarball
    release_tarball="$(get_release_tarball_filename "${release_name}")"
    readonly release_tarball

    local -r editor="${EDITOR:-vim}"
    if ! mycmd.init_bin_no_exit "${editor}"; then
        mycmd.error_output "Required tool '${editor}' not found."
        return 1
    fi

    local release_notes="${DIST_PARENT_DIR}/mycmd-${release_name}-notes.md"

    # shellcheck disable=SC2162
    read -p "Press enter to edit release notes in ${editor}."

    "${editor}" "${release_notes}"

    if [[ ! -s "${release_notes}" ]]; then
        mycmd.error_output "No release notes were created, not creating a release."
        return 1
    fi

    if ! git.create_github_release "${release_name}" "${release_tarball}" "${release_notes}"; then
        mycmd.error_output "Error creating GH release."
        return 1
    fi
}

myproject.register_task create-manual-github-release create_manual_github_release
myproject.register_task_description create-manual-github-release "Create a GitHub release with the specified release version."

# --------------------------------------------------------------------------------------------------
# Task Support Functions
function get_new_local_snapshot_tag_name() {
    local latest_local_snapshot_tag
    if ! latest_local_snapshot_tag="$(get_latest_local_snapshot_tag)"; then
        mycmd.trace "No local snapshot tags created"

        _get_tag_name_from_parts "${LOCAL_SNAPSHOT_TAG_PREFIX}" 0
        return 0
    fi
    readonly latest_local_snapshot_tag

    _get_next_tag_name_from_previous "${latest_local_snapshot_tag}" "${LOCAL_SNAPSHOT_TAG_PREFIX}"
}

function get_latest_local_snapshot_tag() {
    local -a existing_tags=()
    get_local_snapshot_tags existing_tags

    if (("${#existing_tags[@]}" == 0)); then
        return 1
    fi

    echo "${existing_tags[0]}"
}

function _get_tag_name_from_parts() {
    local -r tag_prefix="${1}"
    local -r sequence_number="${2}"

    local date_string
    if ! date_string="$(date '+%Y-%m-%d')"; then
        mycmd.error_output "Unexpected error getting the date string"
        return 1
    fi
    readonly date_string

    echo "${tag_prefix}-r${sequence_number}-${date_string}"
}

function _get_next_tag_name_from_previous() {
    local -r current_tag="${1}"
    local -r tag_prefix="${2}"

    local current_sequence="${current_tag##"${tag_prefix}"-r}"
    current_sequence="${current_sequence%%-*}"
    readonly current_sequence

    local -ir next_sequence=$((current_sequence + 1))
    _get_tag_name_from_parts "${tag_prefix}" "${next_sequence}"
}

function get_local_snapshot_tags() {
    local -r tags_array_ref_name="${1}"
    git.list_tags "${tags_array_ref_name}" "${LOCAL_SNAPSHOT_TAG_PREFIX}-*"
}

readonly SNAPSHOT_WORKTREE_CURRENT_TAG_FILE="${WORKTREES_PARENT_DIR}/.current-snapshot-tag"
function get_snapshot_worktree_current_tag() {
    if [[ -e "${SNAPSHOT_WORKTREE_CURRENT_TAG_FILE}" ]]; then
        cat "${SNAPSHOT_WORKTREE_CURRENT_TAG_FILE}"
        return 0
    else
        return 1
    fi
}

function update_snapshot_worktree_last_used_tag_file() {
    local -r tag="${1}"

    echo "${tag}" >"${SNAPSHOT_WORKTREE_LAST_USED_TAG_FILE}"
}

function update_snapshot_worktree_current_tag_file() {
    local -r tag="${1}"

    echo "${tag}" >"${SNAPSHOT_WORKTREE_CURRENT_TAG_FILE}"
}

function get_development_snapshot_tags() {
    local -r tags_array_ref_name="${1}"
    git.list_tags "${tags_array_ref_name}" "${DEVELOPMENT_SNAPSHOT_TAG_PREFIX}-*"
}

function get_new_development_snapshot_tag_name() {
    local latest_development_snapshot_tag
    if ! latest_development_snapshot_tag="$(get_latest_development_snapshot_tag)"; then
        mycmd.trace "No development snapshot tags created"

        _get_tag_name_from_parts "${DEVELOPMENT_SNAPSHOT_TAG_PREFIX}" 0
        return 0
    fi
    readonly latest_development_snapshot_tag

    mycmd.output "Latest development tag: ${latest_development_snapshot_tag}"

    _get_next_tag_name_from_previous "${latest_development_snapshot_tag}" "${DEVELOPMENT_SNAPSHOT_TAG_PREFIX}"
}

function get_latest_development_snapshot_tag() {
    local -a existing_tags=()
    get_development_snapshot_tags existing_tags

    if (("${#existing_tags[@]}" == 0)); then
        return 1
    fi

    echo "${existing_tags[0]}"
}

function get_snapshot_worktree_last_used_tag() {
    if [[ -e "${SNAPSHOT_WORKTREE_LAST_USED_TAG_FILE}" ]]; then
        cat "${SNAPSHOT_WORKTREE_LAST_USED_TAG_FILE}"
        return 0
    else
        return 1
    fi
}

function get_previous_snapshot_tag() {
    local current_tag="${1}"

    local -a all_tags=()
    if [[ "${current_tag}" = "${LOCAL_SNAPSHOT_TAG_PREFIX}"-* ]]; then
        get_local_snapshot_tags all_tags
    elif [[ "${current_tag}" = "${DEVELOPMENT_SNAPSHOT_TAG_PREFIX}"-* ]]; then
        get_development_snapshot_tags all_tags
    else
        mycmd.error_output "Unexpected tag format of current tag: '${current_tag}'."
    fi

    local -i index
    local -i tag_count="${#all_tags[@]}"
    local -i previous_tag_index

    for ((index = 0; index < tag_count; index++)); do
        if [[ "${current_tag}" = "${all_tags[${index}]}" ]]; then
            previous_tag_index=$((index + 1))

            if ((previous_tag_index == tag_count)); then
                mycmd.error_output "Current tag '${current_tag}' is the oldest tag"
                return 1
            fi

            echo "${all_tags[${previous_tag_index}]}"
            return 0
        fi
    done

    mycmd.error_output "Tag '${current_tag}' not found."
    return 1
}

function get_next_development_snapshot_tag_name_from_previous() {
    _get_next_tag_name_from_previous "${1}" "${DEVELOPMENT_SNAPSHOT_TAG_PREFIX}"
}

function get_next_local_snapshot_tag_name_from_previous() {
    _get_next_tag_name_from_previous "${1}" "${LOCAL_SNAPSHOT_TAG_PREFIX}"
}

function get_release_tarball_filename() {
    local -r mycmd_version="${1}"

    echo "${DIST_PARENT_DIR}/mycmd-${mycmd_version}.tar.gz"
}

function tar_dist_directory() {
    local -r dist_dir="${1}"
    local -r release_tarball="${2}"

    local tarball_options="-cz"

    if mycmd.is_mac_os; then
        if tar --help | grep -q bsdtar; then
            tarball_options="${tarball_options} --no-xattrs --no-mac-metadata"
        fi
    fi

    pushd "${DIST_PARENT_DIR}" &>/dev/null

    # shellcheck disable=SC2086
    if ! tar ${tarball_options} -f "${release_tarball}" "${dist_dir}"; then
        mycmd.error_output "Error creating tarball."
        return 1
    fi

    popd &>/dev/null
}

mycmd.trace "Finished loading the repo task definition file."

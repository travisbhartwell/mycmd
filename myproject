#!/usr/bin/env -S mycmd project run
# -*- mode: shell-script; sh-shell: bash; sh-basic-offset: 4; sh-indentation: 4; coding: utf-8 -*-
# shellcheck shell=bash

set -o nounset -o errexit -o errtrace -o pipefail

project.load_task_library "shell"

#----------------------------------------
# Project Variables
# shellcheck disable=SC2154
readonly BLOG_DIR="${MYPROJECT_BASE_DIR}/blog"
# shellcheck disable=SC2154
readonly TEMPLATE_DIR="${MYPROJECT_BASE_DIR}/templates"
# shellcheck disable=SC2154
readonly WORKING_DIR="${MYPROJECT_BASE_DIR}/.working"

mycmd.trace "The following variables are set:"
mycmd.trace "- BLOG_DIR:     ${BLOG_DIR}"
mycmd.trace "- TEMPLATE_DIR: ${TEMPLATE_DIR}"
mycmd.trace "- WORKING_DIR:  ${WORKING_DIR}"

#----------------------------------------
# Project File Sets

#----------------------------------------
# Just myproject
project.register_fileset MYPROJECT_ONLY
# shellcheck disable=SC2154
project.add_files_to_fileset MYPROJECT_ONLY "${MYPROJECT_PROJECT_FILE}"

project.register_task_with_fileset list-myproject-only project.list-files MYPROJECT_ONLY
project.register_task_with_fileset format-myproject-only project:shell.format MYPROJECT_ONLY
project.register_task_with_fileset lint-myproject-only project:shell.lint MYPROJECT_ONLY

#----------------------------------------
# All Shell Files
project.register_fileset SHELL_FILES
# shellcheck disable=SC2154
project.add_files_to_fileset SHELL_FILES "${MYPROJECT_PROJECT_FILE}"
project.add_files_to_fileset SHELL_FILES gen.sh

project.register_task_with_fileset list-all-shell-files project.list-files SHELL_FILES
project.register_task_with_fileset format-all-shell-files project:shell.format SHELL_FILES
project.register_task_with_fileset lint-all-shell-files project:shell.lint SHELL_FILES

#----------------------------------------
# Blog Entry Files
project.register_fileset BLOG_ENTRIES
project.find_files_for_fileset BLOG_ENTRIES "${BLOG_DIR}" -type f -name '*.md.part'

project.register_task_with_fileset list-blog-entries project.list-files BLOG_ENTRIES

#----------------------------------------
# HTML Template Files
project.register_fileset HTML_TEMPLATE_FILES
project.add_files_to_fileset HTML_TEMPLATE_FILES site.html.template

project.register_task_with_fileset list-html-template-files project.list-files HTML_TEMPLATE_FILES

#----------------------------------------
# CSS Files
project.register_fileset CSS_FILES
project.add_files_to_fileset CSS_FILES style.css

project.register_task_with_fileset list-css-files project.list-files CSS_FILES

#----------------------------------------
# Updating PicoCSS
#
# Based on https://picocss.com/docs
readonly PICO_CSS_GITHUB_URL=git@github.com:picocss/pico.git
# shellcheck disable=SC2154
readonly PICO_CSS_FULL_PATH="${MYPROJECT_BASE_DIR}/pico.min.css"
readonly PICO_CSS_DOWNLOAD_BASE="https://github.com/picocss/pico/archive/refs/tags"

mycmd.trace "Additional variables set:"
mycmd.trace "- PICO_CSS_GITHUB_URL:    ${PICO_CSS_GITHUB_URL}"
mycmd.trace "- PICO_CSS_FULL_PATH:     ${PICO_CSS_FULL_PATH}"
mycmd.trace "- PICO_CSS_DOWNLOAD_BASE: ${PICO_CSS_DOWNLOAD_BASE}"

mycmd.defer_at_startup mycmd.init_bin git
mycmd.defer_at_startup mycmd.init_bin sed
function get_latest_release() {
    mycmd.bin_execute git ls-remote --tags --sort="-version:refname" "${PICO_CSS_GITHUB_URL}" |
        head -n1 |
        mycmd.bin_execute sed -r -n 's/.*refs\/tags\/v(.*)/\1/p'
}

mycmd.defer_at_startup mycmd.init_bin sed
function get_current_used_picocss_version() {
    if [[ ! -e "${PICO_CSS_FULL_PATH}" ]]; then
        echo "missing"
        return 0
    fi

    mycmd.bin_execute sed -r -n 's/.*Pico CSS .* v([^ ]+).*/\1/p' "${PICO_CSS_FULL_PATH}"
}

mycmd.defer_at_startup mycmd.init_bin curl
function update-pico-css-if-needed() {
    local latest
    if ! latest=$(get_latest_release); then
        mycmd.log "Error getting latest release from GitHub"
        return 1
    fi
    readonly latest

    local current
    if ! current=$(get_current_used_picocss_version); then
        mycmd.log "Error getting currently used Pico CSS release"
        return 1
    fi
    readonly current

    if [[ "${latest}" = "${current}" ]]; then
        project.output_only_if_not_quiet "Already at the latest version"
        return 0
    fi

    cd "${WORKING_DIR}"
    local -r tarball="v${latest}.tar.gz"
    local -r download_url="${PICO_CSS_DOWNLOAD_BASE}/${tarball}"
    project.verbose "Downloading PicoCSS from ${download_url}."

    if ! curl -O -sSL "${download_url}"; then
        mycmd.log "Error downloading latest PicoCSS version ${latest} from ${download_url}."
        return 1
    fi

    if ! tar xf "${tarball}"; then
        mycmd.log "Error extracting tarball from ${WORKING_DIR}/${tarball}."
        return 1
    fi

    local -r src_path="${WORKING_DIR}/pico-${latest}/css/pico.min.css"

    if ! cp "${src_path}" "${CSS_DIR}"; then
        mycmd.log "Error copying updated CSS file"
        return 1
    fi
}
project.register_task update-pico-css-if-needed

#----------------------------------------
# Site Generation Commands
function generate() {
    project.output_only_if_not_quiet "Running site generation..."
    ./gen.sh
}
project.register_task generate

mycmd.defer_at_startup mycmd.init_bin tmux
mycmd.defer_at_startup mycmd.init_bin curl
function preview() {
    # TODO When myproject can support task dependencies, use that
    project.execute_tasks generate

    if [[ -v TMUX ]]; then
        project.output_only_if_not_quiet "Starting a Web Server In Tmux"
        mycmd.bin_execute tmux new-window -n preview-http -d -c "${MYPROJECT_BASE_DIR}" 'python3 -m http.server 8080'

        project.output_only_if_not_quiet "Waiting for server to start..."
        mycmd.bin_execute curl --silent --head -X GET --retry 20 --retry-connrefused --retry-delay 1 http://localhost:8080

        open http://localhost:8080
    fi
}
project.register_task preview

mycmd.defer_at_startup mycmd.init_bin find
function clean() {
    mycmd.bin_execute find "${MYPROJECT_BASE_DIR}" -type f -name '*.html' -delete || true
}
project.register_task clean

function archive-output() {
    local -r parent_dir="${1}"
    local -r archive_name="${2}"
    local -r dest_dir="${parent_dir}/${archive_name}"

    # TODO When myproject can support task dependencies, use that
    project.execute_tasks clean generate

    if [[ ! -d "${dest_dir}" ]]; then
        mkdir -p "${dest_dir}"
    fi

    cp index.html style.css "${dest_dir}"

    if [[ ! -d "${dest_dir}/blog" ]]; then
        mkdir -p "${dest_dir}/blog"
    fi

    cp ./blog/*.html "${dest_dir}/blog"
}
project.register_task archive-output

mycmd.defer_at_startup mycmd.init_bin wget
mycmd.defer_at_startup mycmd.init_bin htmlq
function remove-temporary-file() {
    local -r f="${1}"

    if [[ -e "${f}" ]]; then
        rm -f "${f}" || true
    fi
}

function open-all-links() {
    local -r url="${1}"

    local page_html_file
    if ! page_html_file="$(mktemp -q -t "page-XXXXXX.html")"; then
        mycmd.log "Error creating temporary file for the HTML output."
        return 1
    fi
    readonly page_html_file
    mycmd.defer_at_exit remove-temporary-file "${page_html_file}"

    local page_html_filename_only
    page_html_filename_only="$(basename "${page_html_file}")"
    readonly page_html_filename_only

    if ! mycmd.bin_execute wget --output-document "${page_html_file}" --convert-links --quiet "${url}"; then
        mycmd.log "Error fetching content for '${url}'."
        return 1
    fi

    # Automatically close assigned using the `{varname}` redirection syntax
    shopt -s varredir_close
    exec {inputfd}>&0
    readonly inputfd

    local array
    local i

    while mapfile -t -n 5 array && ((${#array[@]})); do
        for i in "${array[@]}"; do
            if [[ "${i}" != "${page_html_filename_only}" ]]; then
                mycmd.output "Opening '${i}'."
                open "${i}"
            fi
        done

        read -r -u "${inputfd}" -p "Press enter to open the next batch."
    done < <(mycmd.bin_execute htmlq --filename "${page_html_file}" --attribute href a)
}
project.register_task open-all-links

#----------------------------------------
# December Adventure
readonly DECEMBER_ADVENTURE_TEMPLATE="${TEMPLATE_DIR}/december-adventure.md.template"

mycmd.init_bin envsubst
function new-december-adventure-post() {
    local post_date
    post_date="$(date '+%Y-%m-%d')"
    readonly post_date

    DAY="$(date '+%-d')"
    export DAY
    YEAR="$(date '+%Y')"
    export YEAR

    local -r post_file_name="${BLOG_DIR}/${post_date}-December-Adventure-${YEAR}:-Day-${DAY}.md"

    if [[ -e "${post_file_name}" ]]; then
        mycmd.log "Post '${post_file_name}' already exists, not overwriting."
        return 1
    fi

    mycmd.bin_execute envsubst \
        <"${DECEMBER_ADVENTURE_TEMPLATE}" \
        >"${post_file_name}"

    mycmd.output "Generated new December Adventure Post for ${post_date}: '${post_file_name}'."
}
project.register_task new-december-adventure-post

project.register_default_task generate

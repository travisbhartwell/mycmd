#!/usr/bin/env -S mycmd project run
# -*- mode: shell-script; sh-shell: bash; sh-basic-offset: 4; sh-indentation: 4; coding: utf-8 -*-
# shellcheck shell=bash

set -o nounset -o errexit -o errtrace -o pipefail

project.load_task_library "shell"

# shellcheck disable=SC2154
readonly BIN_DIR="${MYPROJECT_BASE_DIR}/bin"
readonly TESTING_BASE="${MYPROJECT_BASE_DIR}/testing"
readonly TEST_FILES_BASE="${TESTING_BASE}/tests"
readonly TEST_USER_BASE="${TESTING_BASE}/user-base"
readonly SYSTEM_BASE="${MYPROJECT_BASE_DIR}/mycmd"
readonly VENDOR_DIR="${MYPROJECT_BASE_DIR}/vendor"
readonly TEST_VENDOR_DIR="${TESTING_BASE}/vendor"
readonly VENDOR_WORKING_DIR="${MYPROJECT_BASE_DIR}/vendor/.working"
readonly TMP_WORKING_DIR="${MYPROJECT_BASE_DIR}/tmp"

mycmd.trace "Set the following variables:"
mycmd.trace "- BIN_DIR: ${BIN_DIR}"
mycmd.trace "- TESTING_BASE: ${TESTING_BASE}"
mycmd.trace "- TEST_FILES_BASE: ${TEST_FILES_BASE}"
mycmd.trace "- TEST_USER_BASE: ${TEST_USER_BASE}"
mycmd.trace "- SYSTEM_BASE: ${SYSTEM_BASE}"
mycmd.trace "- VENDOR_DIR: ${VENDOR_DIR}"
mycmd.trace "- TEST_VENDOR_DIR: ${TEST_VENDOR_DIR}"
mycmd.trace "- VENDOR_WORKING_DIR: ${VENDOR_WORKING_DIR}"
mycmd.trace "- TMP_WORKING_DIR: ${TMP_WORKING_DIR}"

project.register_fileset ALL_FILES
project.find_files_for_fileset ALL_FILES "${BIN_DIR}" "${SYSTEM_BASE}" "${TEST_FILES_BASE}" "${TEST_USER_BASE}" -type f
# shellcheck disable=SC2154
project.add_files_to_fileset ALL_FILES "${MYPROJECT_PROJECT_FILE}"

project.register_task_with_fileset list-all-files project.list-files ALL_FILES

project.register_fileset IMPLEMENTATION_FILES
project.find_files_for_fileset IMPLEMENTATION_FILES "${BIN_DIR}" "${SYSTEM_BASE}" -type f
project.register_task_with_fileset list-implementation-files project.list-files IMPLEMENTATION_FILES

function _update_vendored_file_for_vendor_base_dir() {
    local -r source_path="${VENDOR_WORKING_DIR}/${1}"
    local -r vendor_dir="${2}"
    local -r dest_path="${vendor_dir}/${3}"
    local -r dest_dir=$(dirname "${dest_path}")

    if [[ ! -e "${source_path}" ]]; then
        mycmd.log "Source file '${source_path}' not found."
        return 1
    fi

    if [[ ! -e "${dest_dir}" ]]; then
        mkdir -p "${dest_dir}"
    fi

    if [[ -e "${dest_path}" ]]; then
        if diff -q "${source_path}" "${dest_path}"; then
            mycmd.log "Vendored file '${dest_path}' is up to date."
            return 0
        fi
    fi

    mycmd.log "Updating vendor destination '${dest_path}'."
    cp -a "${source_path}" "${dest_path}"
}

function _update_vendored_file() {
    _update_vendored_file_for_vendor_base_dir "${1}" "${VENDOR_DIR}" "${2}"
}

function _update_vendored_test_file() {
    _update_vendored_file_for_vendor_base_dir "${1}" "${TEST_VENDOR_DIR}" "${2}"
}

function update-ansi() {
    # https://github.com/fidian/ansi
    if [[ ! -e "${VENDOR_WORKING_DIR}/ansi" ]]; then
        mkdir -p "${VENDOR_WORKING_DIR}" 2>/dev/null || true
        cd "${VENDOR_WORKING_DIR}"
        mycmd.output "Cloning ansi git repository."
        git clone --quiet git@github.com:fidian/ansi.git
    fi

    cd "${VENDOR_WORKING_DIR}/ansi"
    mycmd.output "Pulling latest ansi changes from git."
    git pull --rebase --quiet

    _update_vendored_file "ansi/ansi" "ansi"
}
project.register_task update-ansi

function update-bashup-events() {
    # https://github.com/bashup/events/tree/bash44
    if [[ ! -e "${VENDOR_WORKING_DIR}/bashup.events" ]]; then
        mkdir -p "${VENDOR_WORKING_DIR}" 2>/dev/null || true
        cd "${VENDOR_WORKING_DIR}"
        mycmd.output "Cloning bashup.events git repository."
        git clone --quiet -b bash44 git@github.com:bashup/events.git bashup.events
    fi

    cd "${VENDOR_WORKING_DIR}/bashup.events"
    mycmd.output "Pulling latest bashup.events changes from git."
    git pull --rebase --quiet

    _update_vendored_file "bashup.events/bashup.events" "bashup.events"
}
project.register_task update-bashup-events

function update-shunit2() {
    # https://github.com/kward/shunit2/tree/master
    if [[ ! -e "${VENDOR_WORKING_DIR}/shunit2" ]]; then
        mkdir -p "${VENDOR_WORKING_DIR}" 2>/dev/null || true
        cd "${VENDOR_WORKING_DIR}"
        mycmd.output "Cloning shunit2 git repository."
        git clone --quiet git@github.com:kward/shunit2.git shunit2
    fi

    cd "${VENDOR_WORKING_DIR}/shunit2"
    mycmd.output "Pulling latest shunit2 changes from git."
    git pull --rebase --quiet

    _update_vendored_test_file "shunit2/shunit2" "shunit2"
    _update_vendored_test_file "shunit2/shunit2_test_helpers" "shunit2_test_helpers"
}
project.register_task update-shunit2

mycmd.defer_at_startup mycmd.init_bin sed
function list-mycmd-lib-functions() {
    local -r mycmd_lib="${SYSTEM_BASE}/mycmd-lib"

    grep -E '^[[:space:]]*function' "${mycmd_lib}" \
        | mycmd.bin_execute sed -n 's/.*function \(.*\)() {/\1/p' \
        | sort -u
}
project.register_task list-mycmd-lib-functions

mycmd.init_bin grep
function catalog-mycmd-lib-function-callers() {
    local -n implementation_fileset="${1}"
    local -a functions

    readarray -t functions < <(list-mycmd-lib-functions || true)

    local fn
    local fn_pattern
    local count
    local -a data=()

    project.output_only_if_not_quiet "Cataloging function from mycmd-lib across all implementation files."

    for fn in "${functions[@]}"; do
        local impl_file
        for impl_file in "${implementation_fileset[@]}"; do
            project.verbose "Searching for function '${fn}' in file '${impl_file}'."

            fn_pattern="${fn/./\\.}"
            count="$(mycmd.bin_execute grep -P "(?<!function )[[:<:]]${fn_pattern}[[:>:]]" "${impl_file}" \
                | mycmd.bin_execute grep -P -c -v ".*#.*[[:<:]]${fn_pattern}[[:>:]].*" || true)"
            data+=("${fn},${impl_file},${count}")
        done
    done

    local -r output_file="${TMP_WORKING_DIR}/fn-call-counts.csv"

    echo "function,file,count" >"${output_file}"

    (
        local line
        for line in "${data[@]}"; do
            echo "${line}"
        done
    ) | sort -t, -k3 -nr >>"${output_file}"

    project.output_only_if_not_quiet "Wrote results to ${output_file}."
}
project.register_task_with_fileset catalog-mycmd-lib-function-callers catalog-mycmd-lib-function-callers IMPLEMENTATION_FILES

#----------------------------------------
# Test execution
project.register_fileset ALL_TEST_FILES
project.find_files_for_fileset ALL_TEST_FILES "${TEST_FILES_BASE}" -type f -name '*-test'

project.register_task_with_fileset list-test-files project.list-files ALL_TEST_FILES

mycmd.defer_at_startup mycmd.init_bin gum
function summarize_test_results() {
    local -n results_ref="${1}"

    (
        echo "Testing Summary:"
        echo "| Result | Test File |"
        echo "|--------|-----------|"
        local test_file
        local result

        for test_file in "${!results_ref[@]}"; do
            result="${results_ref["${test_file}"]}"
            if ((result == 0)); then
                echo "| ✅︎ | ${test_file} |"
            else
                echo "| ❌ | ${test_file} |"
            fi
        done
    ) | mycmd.bin_execute gum format --type=markdown
}

function execute-test() {
    local -r test_file="${1}"

    if [[ ! -e "${test_file}" ]]; then
        mycmd.log "Test file not found: ${test_file}"
        return 1
    fi

    local result=0
    mycmd.log "Executing test file: ${test_file}"
    /usr/bin/env MYCMD_SYSTEM_BASE_DIR="${MYCMD_SYSTEM_BASE_DIR:-${SYSTEM_BASE}}" \
        MYCMD_USER_BASE_DIR="${MYCMD_USER_BASE_DIR:-${TEST_USER_BASE}}" \
        MYCMD_VENDOR_DIR="${MYCMD_VENDOR_DIR:-${VENDOR_DIR}}" \
        PATH="${BIN_DIR}:${PATH}" \
        "${test_file}" || result=$?

    mycmd.log "Result of ${test_file}: ${result}"
    return "${result}"
}

function execute-all-tests() {
    local -n test_fileset="${1}"
    local test_file
    local -A results=()
    local result

    for test_file in "${test_fileset[@]}"; do
        result=0

        execute-test "${test_file}" || result=$?
        # shellcheck disable=SC2034
        results["${test_file}"]="${result}"
    done

    summarize_test_results results
}

project.register_task_with_fileset execute-all-tests execute-all-tests ALL_TEST_FILES

#----------------------------------------
# Benchmarking
mycmd.defer_at_startup mycmd.init_bin hyperfine
function execute-benchmark() {
    /usr/bin/env MYCMD_SYSTEM_BASE_DIR="${MYCMD_SYSTEM_BASE_DIR:-${SYSTEM_BASE}}" \
        MYCMD_USER_BASE_DIR="${MYCMD_USER_BASE_DIR:-${TEST_USER_BASE}}" \
        MYCMD_VENDOR_DIR="${MYCMD_VENDOR_DIR:-${VENDOR_DIR}}" \
        PATH="${BIN_DIR}:${PATH}" \
        hyperfine \
        --warmup 3 \
        -- "${@}"
}
project.register_task benchmark-help execute-benchmark 'mycmd project --help'
project.register_task benchmark-list-project-tasks execute-benchmark 'mycmd project list-tasks'

#----------------------------------------
# Code formatting
project.register_task_with_fileset format project:shell.format ALL_FILES

#----------------------------------------
# Code Lint
project.register_task_with_fileset lint project:shell.lint ALL_FILES

#----------------------------------------
# Run everything
function all() {
    project.execute_tasks format lint execute-all-tests
}
project.register_task all
project.register_default_task all
